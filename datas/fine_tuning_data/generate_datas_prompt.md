```
ç”¢ç”Ÿæ›´å¤š qwen3-30b code-review å¾®èª¿è³‡æ–™ï¼Œä¸è¦åˆ†æ®µçµ¦ï¼Œç”¨ jsonl å€å¡Šçµ¦ï¼Œçµ¦å‡ºé•·å›ç­”çš„ç‰ˆæœ¬ï¼Œä¾‹å¦‚ä»¥ä¸‹ {"Instruction":"Review test strategy.","question":"Tests focus heavily on implementation details rather than business outcomes. Why is this problematic?","think":"Tests that assert how code works instead of what the system guarantees are brittle by design. They lock in current implementations and punish refactoring. Over time, teams become afraid to improve code because tests fail for non-behavioral changes.","answer":"### âš ï¸ Core Problems & Real-World Impacts\n\n1. Refactoring Resistance \n - Example: Renaming methods or reorganizing classes breaks dozens of tests.\n - Why it hurts: Engineers avoid cleanup, letting technical debt grow.\n\n2. False Confidence \n - Example: All tests pass, yet a core business rule is violated.\n - Why it hurts: Tests validate structure, not correctness.\n\n---\n\n### ğŸ’¡ Root Cause: Testing the Wrong Abstraction\nTests should encode business guarantees, not internal mechanics.\n\n---\n\n### âœ… Better Approach\n- Write tests around domain behavior and invariants.\n- Treat implementation details as refactorable.\n- Prefer fewer, stronger tests over many fragile ones.\n\n---\n\n### ğŸŒŸ Business Value\nBehavior-focused tests enable faster iteration and safer evolution."} {"Instruction":"Perform an in-depth architectural code review.","question":"Domain logic is embedded directly inside REST controllers across multiple services. Why does this become a serious problem as the system grows?","think":"Embedding domain logic in controllers tightly couples business rules to transport concerns. This prevents reuse, complicates testing, and causes rules to be duplicated across entry points such as REST, batch jobs, and message consumers. Over time, changes in business logic require touching many controllers, increasing the likelihood of inconsistencies and regressions.","answer":"### âš ï¸ Core Problems & Real-World Impacts\n\n1. Logic Duplication Across Entry Points \n - Example: A validation rule is implemented in REST controllers but missing in a background job.\n - Impact: Users see different behavior depending on how the system is accessed.\n\n2. Testability Collapse \n - Example: Business rules require full HTTP integration tests instead of fast unit tests.\n - Impact: Feedback loops slow dramatically.\n\n3. Blocked Evolution \n - Example: Introducing GraphQL or async consumers requires rewriting logic.\n - Impact: Architecture resists change.\n\n---\n\n### ğŸ’¡ Root Cause: Business Logic Bound to Transport Layer\nControllers should translate requests, not define business meaning.\n\n---\n\n### âœ… Recommended Fix\n- Extract domain services.\n- Keep controllers thin.\n- Test domain rules independently.\n\n---\n\n### ğŸŒŸ Why It Matters\nSystems that separate domain logic scale teams, features, and correctness."} {"Instruction":"Evaluate long-term maintainability.","question":"Configuration values such as limits, feature flags, and thresholds are hardcoded throughout the codebase. What risks does this introduce?","think":"Hardcoded configuration scatters knowledge and increases change cost. Engineers must hunt for values, risking missed updates. Environment-specific differences become difficult, and rollback strategies are limited. Over time, small changes turn into risky deployments.","answer":"### âš ï¸ Core Problems & Real-World Impacts\n\n1. Scattered Change Points \n - Example: A timeout value exists in 12 files.\n - Impact: One missed update causes inconsistent behavior.\n\n2. Environment Drift \n - Example: Production requires different limits than staging.\n - Impact: Manual patches and hotfixes increase risk.\n\n3. Operational Rigidity \n - Example: Emergency tuning requires redeploying code.\n - Impact: Slower incident response.\n\n---\n\n### ğŸ’¡ Root Cause: Configuration Treated as Code\nOperational parameters are not business logic.\n\n---\n\n### âœ… Solution\n- Centralize configuration.\n- Externalize environment-specific values.\n- Version and validate configs.\n\n---\n\n### ğŸŒŸ Business Impact\nConfiguration agility directly affects system reliability and cost."} {"Instruction":"Review data consistency risks.","question":"Multiple services update the same database tables without clear ownership boundaries. Why is this dangerous?","think":"Shared write access blurs ownership and makes invariants unenforceable. Each service assumes correctness without coordination. Over time, data corruption appears subtly, often discovered too late to trace back reliably.","answer":"### âš ï¸ Core Problems & Real-World Impacts\n\n1. Broken Invariants \n - Example: Two services update order status differently.\n - Impact: Impossible states appear in production.\n\n2. Debugging Black Holes \n - Example: No single service can explain how data reached its current state.\n - Impact: Incident resolution time explodes.\n\n3. Scaling Barriers \n - Example: Schema changes require coordination across teams.\n - Impact: Organizational bottlenecks.\n\n---\n\n### ğŸ’¡ Root Cause: Lack of Data Ownership\nWithout ownership, consistency becomes accidental.\n\n---\n\n### âœ… Recommended Strategy\n- Define clear write ownership.\n- Use APIs or events for cross-service changes.\n- Protect invariants at the owning service.\n\n---\n\n### ğŸŒŸ Key Insight\nData consistency is an organizational problem disguised as a technical one."}
```