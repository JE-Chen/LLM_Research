{"Instruction":"Review the code for readability and maintainability without assuming a specific language.","question":"The function mixes business logic with I/O operations. What should be improved?","think":"Identify separation-of-concerns issues and propose modularization.","answer":"Separate business logic from I/O via clear layers (e.g., service vs. adapter). Introduce interfaces for I/O, pass dependencies via injection, and add unit tests for pure logic. Document data flow and error handling boundaries."}
{"Instruction":"Assess error handling strategy and resilience.","question":"The code catches a generic exception and logs a message. Is this sufficient?","think":"Evaluate granularity, recovery paths, and observability.","answer":"Avoid catching generic exceptions unless at process boundaries. Catch specific error types, include actionable context, and propagate when appropriate. Use structured logging with correlation IDs and ensure retries/backoff where safe."}
{"Instruction":"Evaluate naming conventions and intent clarity.","question":"Variables like x1, tmp, and doIt are used throughout. What’s the impact?","think":"Check semantic clarity and consistency.","answer":"Rename to domain-relevant, descriptive names. Use consistent casing and verb-noun patterns for functions. Avoid ambiguous names; prefer explicit intent (e.g., calculateInvoiceTotal). Update comments/tests to reflect new names."}
{"Instruction":"Check performance characteristics and algorithmic complexity.","question":"A nested loop processes a large dataset. Any concerns?","think":"Estimate complexity and memory usage.","answer":"Analyze worst-case complexity—likely O(n·m). Consider pre-indexing, streaming, or batching. Use lazy iteration and avoid building large intermediate collections. Profile hotspots and add benchmarks to validate improvements."}
{"Instruction":"Review concurrency safety and shared state management.","question":"Multiple threads update a shared cache map. What risks exist?","think":"Identify race conditions and visibility issues.","answer":"Use thread-safe structures or synchronization primitives. Prefer immutable snapshots or copy-on-write for reads. Define clear ownership, avoid double-checked locking pitfalls, and add tests for concurrent access patterns."}
{"Instruction":"Assess input validation and trust boundaries.","question":"User-provided data is passed directly to a parser. Is this acceptable?","think":"Consider validation, sanitization, and failure modes.","answer":"Validate schema and types before parsing. Enforce size limits, reject malformed inputs, and sanitize dangerous characters. Fail fast with clear errors and log validation failures with minimal sensitive data."}
{"Instruction":"Evaluate test coverage and test quality.","question":"Only happy-path tests exist. What should be added?","think":"Identify critical edge cases and negative scenarios.","answer":"Add tests for error paths, boundary values, concurrency, and resource exhaustion. Include property-based tests for invariants and integration tests for external dependencies. Measure coverage but prioritize meaningful assertions."}
{"Instruction":"Check configuration management and environment handling.","question":"Credentials are hardcoded in the code. What’s the fix?","think":"Promote secure externalization and rotation.","answer":"Remove hardcoded secrets. Load from environment or a secret manager, enforce rotation, and restrict scope. Add configuration validation and document required variables. Ensure secrets never appear in logs or dumps."}
{"Instruction":"Assess logging strategy and observability.","question":"The code logs only errors. Is that enough?","think":"Balance signal vs. noise and traceability.","answer":"Add structured logs at key lifecycle events (start, success, retry). Include request IDs and latency metrics. Use levels appropriately, avoid PII, and integrate with tracing to correlate across services."}
{"Instruction":"Evaluate API design and backward compatibility.","question":"A public function signature changed without versioning. Concerns?","think":"Consider consumer impact and migration path.","answer":"Avoid breaking changes; introduce versioned endpoints or overloads. Provide deprecation notices, changelog entries, and migration guides. Add contract tests to protect public interfaces."}
{"Instruction":"Review resource management and lifecycle.","question":"Files and sockets are opened but not always closed. What’s the risk?","think":"Check leaks and deterministic cleanup.","answer":"Ensure deterministic cleanup via RAII/try-with-resources/finalizers as appropriate. Centralize lifecycle management, handle partial failures, and add tests that detect leaks under stress."}
{"Instruction":"Assess security posture for injection risks.","question":"String concatenation builds dynamic queries. Safe?","think":"Evaluate injection vectors and parameterization.","answer":"Use parameterized queries or prepared statements. Escape identifiers safely, avoid building queries from untrusted input, and validate allowed operations. Add tests with malicious payloads to confirm defenses."}
{"Instruction":"Evaluate modularity and dependency boundaries.","question":"A utility module imports many unrelated components. Any issues?","think":"Identify coupling and cohesion problems.","answer":"Split utilities by cohesive responsibility. Reduce imports to minimal interfaces, avoid circular dependencies, and document module contracts. Introduce dependency inversion to decouple high-level logic from low-level details."}
{"Instruction":"Check internationalization and locale handling.","question":"Dates and numbers are formatted with defaults. Is that robust?","think":"Consider locale, timezone, and user preferences.","answer":"Use explicit locale/timezone settings. Normalize to UTC for storage, format per user locale, and handle daylight saving transitions. Add tests for multiple locales and edge dates."}
{"Instruction":"Assess data validation and schema evolution.","question":"The code assumes fields always exist in JSON payloads. Safe?","think":"Plan for missing/extra fields and versioning.","answer":"Validate against a schema, provide defaults, and handle unknown fields gracefully. Version payloads, add migration logic, and log schema mismatches with actionable context."}
{"Instruction":"Evaluate error messages and developer experience.","question":"Errors return generic 'failed' messages. Improve?","think":"Promote actionable, non-leaky feedback.","answer":"Provide concise, actionable messages with context (operation, identifier). Avoid leaking secrets or internals. Map internal errors to user-friendly codes and document troubleshooting steps."}
{"Instruction":"Review immutability and side-effect control.","question":"Functions mutate input collections. Any concerns?","think":"Consider predictability and defensive copying.","answer":"Avoid mutating caller-owned inputs; return new values or document mutation clearly. Use immutable data structures where feasible and add tests to detect unintended side effects."}
{"Instruction":"Assess caching strategy and invalidation.","question":"Cache entries rarely expire. What could go wrong?","think":"Balance freshness, memory, and consistency.","answer":"Define TTLs based on data volatility, support manual invalidation, and track hit/miss metrics. Guard against stale reads in critical paths and consider cache stampede protection."}
{"Instruction":"Evaluate portability and platform assumptions.","question":"Path separators and line endings are hardcoded. Issues?","think":"Promote cross-platform compatibility.","answer":"Use platform-agnostic APIs for paths and I/O. Normalize line endings where needed, avoid shell-specific constructs, and add CI checks across multiple OS environments."}
{"Instruction":"Check documentation and code comments quality.","question":"Comments explain what the code does line-by-line. Helpful?","think":"Prefer intent over narration.","answer":"Replace narrations with intent-focused comments: why, constraints, and trade-offs. Keep code self-explanatory via naming and structure. Maintain a concise README with usage, configuration, and known limitations."}
{"Instruction":"Review dependency management and version control practices.","question":"The project uses outdated libraries without version pinning. What’s the risk?","think":"Consider reproducibility, security, and compatibility.","answer":"Outdated libraries may contain vulnerabilities. Pin versions to ensure reproducibility, regularly audit dependencies, and update with changelogs. Use automated tools to detect CVEs and avoid transitive dependency drift."}
{"Instruction":"Evaluate memory usage and resource efficiency.","question":"Large arrays are kept in memory even after processing. Any concerns?","think":"Check for leaks and unnecessary retention.","answer":"Release references after use, apply streaming or chunking, and prefer generators/iterators. Profile memory usage and add monitoring to detect leaks under load."}
{"Instruction":"Assess code style consistency and formatting.","question":"Indentation and brace styles vary across files. What’s the impact?","think":"Consider readability and team collaboration.","answer":"Adopt a consistent style guide (e.g., lint rules). Automate formatting with tools, enforce in CI, and document conventions to reduce cognitive load."}
{"Instruction":"Check modular testability and isolation.","question":"Functions rely on global state during tests. Is this acceptable?","think":"Evaluate reproducibility and isolation.","answer":"Avoid global state; inject dependencies or use mocks. Reset state between tests and ensure tests run independently in parallel environments."}
{"Instruction":"Review scalability and horizontal growth potential.","question":"The system processes requests sequentially. Any issues?","think":"Consider throughput and bottlenecks.","answer":"Introduce concurrency or async processing. Use queues for workloads, scale horizontally with load balancers, and monitor throughput metrics."}
{"Instruction":"Evaluate code comments for maintainability.","question":"Comments are outdated and contradict the code. What’s the risk?","think":"Check synchronization between code and documentation.","answer":"Outdated comments mislead developers. Update or remove them, prefer self-explanatory code, and enforce documentation reviews in pull requests."}
{"Instruction":"Assess API error handling and client communication.","question":"The API returns HTTP 200 even on failures. Is this correct?","think":"Consider REST conventions and client usability.","answer":"Return appropriate status codes (4xx, 5xx). Include structured error payloads, document error schema, and add integration tests for client handling."}
{"Instruction":"Check immutability in concurrent contexts.","question":"Shared objects are mutated across threads. Safe?","think":"Evaluate race conditions and predictability.","answer":"Prefer immutable data structures or synchronization. Document mutation points, add concurrency tests, and consider actor/message-passing models."}
{"Instruction":"Evaluate build and deployment automation.","question":"Build steps are manual and undocumented. Any concerns?","think":"Consider reproducibility and CI/CD pipelines.","answer":"Automate builds with scripts or CI tools. Document steps, enforce reproducible environments, and add deployment validations."}
{"Instruction":"Review code duplication and DRY principle.","question":"Similar logic is copy-pasted across modules. What’s the impact?","think":"Check maintainability and bug propagation.","answer":"Refactor into reusable functions or libraries. Reduce duplication, centralize logic, and add unit tests to ensure correctness across contexts."}
{"Instruction":"Assess boundary checks and defensive programming.","question":"Array indexing assumes valid ranges. Any risks?","think":"Consider runtime errors and security.","answer":"Add boundary checks, validate inputs, and handle exceptions gracefully. Use assertions in debug builds and fuzz tests for robustness."}
{"Instruction":"Evaluate lifecycle hooks and cleanup routines.","question":"Temporary files are left after execution. What’s the consequence?","think":"Check disk usage and security.","answer":"Ensure cleanup in finally blocks or lifecycle hooks. Use OS temp directories, add monitoring for leftover files, and enforce quotas."}
{"Instruction":"Review modularity of configuration files.","question":"All settings are hardcoded in a single file. Any issues?","think":"Consider flexibility and environment separation.","answer":"Split configs by environment, externalize sensitive values, and support overrides. Document defaults and validate configs at startup."}
{"Instruction":"Assess code extensibility and open/closed principle.","question":"Adding new features requires editing core logic. Is this ideal?","think":"Check maintainability and design patterns.","answer":"Refactor with abstractions or strategy patterns. Keep core stable, extend via plugins or inheritance, and add regression tests."}
{"Instruction":"Evaluate portability of numeric types.","question":"Integers are assumed to fit in 32 bits. Safe?","think":"Consider overflow and cross-platform behavior.","answer":"Use language-provided safe types, validate ranges, and add tests for edge cases. Document assumptions and prefer arbitrary-precision libraries if needed."}
{"Instruction":"Check monitoring and alerting integration.","question":"The system has no runtime metrics. What’s the risk?","think":"Consider observability and incident response.","answer":"Add metrics for latency, errors, and resource usage. Integrate with dashboards and alerts. Test alert thresholds under simulated load."}
{"Instruction":"Assess modular separation of UI and logic.","question":"UI code directly manipulates business rules. Any concerns?","think":"Check coupling and testability.","answer":"Separate UI from business logic via MVC/MVVM. Keep rules in services, expose APIs, and test logic independently of UI rendering."}
{"Instruction":"Evaluate serialization and backward compatibility.","question":"Binary format changes without migration. Safe?","think":"Consider data corruption and versioning.","answer":"Introduce versioned schemas, provide migration tools, and validate compatibility. Add tests for old/new formats and document upgrade paths."}
{"Instruction":"Review code reuse and abstraction.","question":"Low-level details are repeated in multiple modules. What’s the impact?","think":"Check abstraction and maintainability.","answer":"Abstract common logic into utilities or frameworks. Reduce duplication, enforce contracts, and document reusable components."}
{"Instruction":"Review modularity of error recovery routines.","question":"Recovery logic is duplicated in multiple modules. Any concerns?","think":"Check maintainability and consistency.","answer":"Centralize recovery routines in a shared utility. Ensure consistent retry/backoff strategies and document usage patterns."}
{"Instruction":"Evaluate boundary conditions in numeric computations.","question":"Division operations assume non-zero denominators. Safe?","think":"Consider runtime exceptions and validation.","answer":"Add explicit zero checks, return safe defaults, or raise clear errors. Include unit tests for edge cases."}
{"Instruction":"Assess code readability with nested conditionals.","question":"Deeply nested if-else blocks exist. What’s the impact?","think":"Consider clarity and maintainability.","answer":"Refactor into guard clauses or switch constructs. Extract logic into helper functions to reduce nesting depth."}
{"Instruction":"Check lifecycle of background tasks.","question":"Background threads are spawned but never joined. Any risks?","think":"Consider resource leaks and shutdown behavior.","answer":"Ensure proper thread termination or use managed executors. Add shutdown hooks and monitor orphaned threads."}
{"Instruction":"Evaluate modular separation of concerns.","question":"Database queries are embedded directly in UI code. Issues?","think":"Check coupling and testability.","answer":"Move queries into data access layers. Keep UI focused on presentation, and test logic independently of persistence."}
{"Instruction":"Review exception propagation strategy.","question":"Exceptions are swallowed silently. Is this acceptable?","think":"Consider debugging and reliability.","answer":"Avoid silent catches. Log with context, rethrow when necessary, and provide actionable error messages."}
{"Instruction":"Assess maintainability of configuration constants.","question":"Magic numbers appear throughout the code. Any concerns?","think":"Check readability and flexibility.","answer":"Replace with named constants or enums. Document meaning, centralize definitions, and avoid duplication."}
{"Instruction":"Evaluate modularity of logging.","question":"Logging statements are scattered inconsistently. What’s the risk?","think":"Consider observability and consistency.","answer":"Centralize logging via a framework. Define levels, enforce structured formats, and integrate with monitoring tools."}
{"Instruction":"Check portability of file handling.","question":"File paths assume a specific OS directory structure. Safe?","think":"Consider cross-platform compatibility.","answer":"Use language APIs for paths, avoid hardcoded separators, and test across multiple OS environments."}
{"Instruction":"Assess correctness of loop termination.","question":"Loops rely on external flags without validation. Any issues?","think":"Check infinite loop risks.","answer":"Validate flags, add explicit termination conditions, and include watchdogs or timeouts for safety."}
{"Instruction":"Evaluate modularity of serialization routines.","question":"Serialization logic is duplicated across classes. Concerns?","think":"Check maintainability and consistency.","answer":"Refactor into reusable serializers. Ensure versioning support and add tests for backward compatibility."}
{"Instruction":"Review immutability of shared collections.","question":"Shared lists are modified concurrently. Risks?","think":"Consider race conditions and predictability.","answer":"Use thread-safe collections or immutability. Document mutation points and add concurrency tests."}
{"Instruction":"Assess correctness of resource cleanup.","question":"Database connections are not closed after use. What’s the impact?","think":"Check leaks and stability.","answer":"Ensure connections are closed in finally blocks or use connection pools. Monitor for leaks under load."}
{"Instruction":"Evaluate modularity of validation logic.","question":"Validation rules are scattered across modules. Any concerns?","think":"Check consistency and maintainability.","answer":"Centralize validation in a dedicated layer. Document rules, reuse across contexts, and add schema tests."}
{"Instruction":"Review scalability of batch processing.","question":"Large datasets are loaded fully into memory. Issues?","think":"Consider performance and scalability.","answer":"Use streaming or pagination. Profile memory usage, add monitoring, and validate under stress conditions."}
{"Instruction":"Assess correctness of time handling.","question":"Timestamps are compared without timezone normalization. Safe?","think":"Consider consistency and accuracy.","answer":"Normalize to UTC for comparisons. Document timezone assumptions and add tests across multiple locales."}
{"Instruction":"Evaluate modularity of API clients.","question":"API calls are hardcoded in multiple modules. Risks?","think":"Check duplication and maintainability.","answer":"Refactor into reusable client libraries. Handle retries, errors, and versioning consistently."}
{"Instruction":"Review correctness of type casting.","question":"Unchecked type casts are used. Any concerns?","think":"Consider runtime errors and safety.","answer":"Use safe casting methods, validate types before casting, and add tests for invalid inputs."}
{"Instruction":"Assess modularity of security checks.","question":"Authorization logic is embedded in controllers. Issues?","think":"Check separation of concerns.","answer":"Move authorization into middleware or services. Document policies, centralize enforcement, and add tests."}
{"Instruction":"Evaluate correctness of resource allocation.","question":"Memory buffers are allocated without size checks. Risks?","think":"Consider overflow and stability.","answer":"Validate sizes before allocation, handle failures gracefully, and add stress tests for large inputs."}
{"Instruction":"Review correctness of boundary validation.","question":"Function assumes positive integers only. Risks?","think":"Consider invalid inputs.","answer":"Add validation for negative and zero values. Document constraints and add unit tests."}
{"Instruction":"Evaluate modularity of dependency usage.","question":"Business logic imports low-level utilities directly. Issues?","think":"Check coupling.","answer":"Introduce abstraction layers. Reduce direct imports and enforce dependency inversion."}
{"Instruction":"Assess correctness of error propagation.","question":"Errors are logged but not rethrown. Concerns?","think":"Consider debugging and reliability.","answer":"Rethrow or wrap errors with context. Ensure logs include identifiers and actionable details."}
{"Instruction":"Review maintainability of configuration.","question":"Config values are duplicated in multiple files. Issues?","think":"Check consistency.","answer":"Centralize configs in one source. Document defaults and validate at startup."}
{"Instruction":"Evaluate correctness of loop termination.","question":"While loops lack explicit exit conditions. Risks?","think":"Consider infinite loops.","answer":"Add explicit conditions, watchdog timers, and tests for termination scenarios."}
{"Instruction":"Assess modularity of persistence.","question":"Database queries are scattered. Issues?","think":"Check maintainability.","answer":"Centralize queries in a repository layer. Document schema and add integration tests."}
{"Instruction":"Review correctness of string encoding.","question":"Strings are assumed UTF-8. Risks?","think":"Consider portability.","answer":"Validate encoding, normalize inputs, and add tests for multiple encodings."}
{"Instruction":"Evaluate maintainability of build process.","question":"Build requires manual steps. Issues?","think":"Check reproducibility.","answer":"Automate builds with CI/CD. Document steps and enforce reproducibility."}
{"Instruction":"Assess correctness of concurrency.","question":"Shared counters lack synchronization. Risks?","think":"Consider race conditions.","answer":"Use atomic operations or locks. Add concurrency tests and monitor correctness."}
{"Instruction":"Review modularity of validation.","question":"Validation logic is embedded in controllers. Issues?","think":"Check separation of concerns.","answer":"Move validation into dedicated services. Document rules and add schema tests."}
{"Instruction":"Evaluate correctness of resource cleanup.","question":"Connections remain open after use. Risks?","think":"Consider leaks.","answer":"Close connections deterministically. Use pools and monitor resource usage."}
{"Instruction":"Assess maintainability of naming.","question":"Mixed casing styles exist. Issues?","think":"Check readability.","answer":"Adopt consistent naming conventions. Enforce with linters and document style guide."}
{"Instruction":"Review correctness of serialization.","question":"Objects serialized without versioning. Risks?","think":"Consider compatibility.","answer":"Add version fields, migration tools, and backward compatibility tests."}
{"Instruction":"Evaluate modularity of monitoring.","question":"Metrics are inconsistent. Issues?","think":"Check observability.","answer":"Standardize metrics collection. Integrate with dashboards and document conventions."}
{"Instruction":"Assess correctness of exception handling.","question":"Generic catch blocks used. Risks?","think":"Consider debugging.","answer":"Catch specific exceptions. Provide actionable messages and avoid swallowing errors."}
{"Instruction":"Review maintainability of CI/CD.","question":"Pipeline scripts differ across repos. Issues?","think":"Check consistency.","answer":"Centralize templates. Reuse workflows and document pipeline steps."}
{"Instruction":"Evaluate correctness of boundary checks.","question":"Indexing assumes valid ranges. Risks?","think":"Consider runtime errors.","answer":"Add bounds checks, validate inputs, and include edge case tests."}
{"Instruction":"Assess modularity of authentication.","question":"Auth logic duplicated. Issues?","think":"Check consistency.","answer":"Centralize authentication. Document policies and add integration tests."}
{"Instruction":"Review correctness of resource lifecycle.","question":"Files not closed. Risks?","think":"Consider leaks.","answer":"Ensure closure in finally blocks. Use managed APIs and monitor usage."}
{"Instruction":"Evaluate maintainability of dependency updates.","question":"Libraries outdated. Issues?","think":"Check security.","answer":"Update regularly. Audit CVEs and automate dependency checks."}
{"Instruction":"Assess correctness of concurrency models.","question":"Locks nested. Risks?","think":"Consider deadlocks.","answer":"Avoid nested locks. Use fine-grained locking and add concurrency tests."}
{"Instruction":"Review modularity of UI.","question":"UI manipulates business rules. Issues?","think":"Check coupling.","answer":"Separate UI from logic via MVC/MVVM. Test logic independently."}
{"Instruction":"Evaluate correctness of error codes.","question":"API returns 200 on failure. Risks?","think":"Consider client usability.","answer":"Return proper codes. Document schema and add integration tests."}
{"Instruction":"Assess maintainability of comments.","question":"Comments outdated. Issues?","think":"Check synchronization.","answer":"Update or remove outdated comments. Focus on intent, not narration."}
{"Instruction":"Review correctness of time handling.","question":"Timestamps compared without normalization. Risks?","think":"Consider consistency.","answer":"Normalize to UTC. Document assumptions and add tests."}
{"Instruction":"Evaluate modularity of dependency management.","question":"Utility imports unrelated components. Issues?","think":"Check cohesion.","answer":"Split utilities. Reduce imports and document contracts."}
{"Instruction":"Assess correctness of lifecycle hooks.","question":"Shutdown hooks missing. Risks?","think":"Consider cleanup.","answer":"Add shutdown hooks. Ensure graceful termination and test under stress."}
{"Instruction":"Review maintainability of deployment.","question":"Deployments manual. Issues?","think":"Check reproducibility.","answer":"Automate deployments. Document steps and add validations."}
{"Instruction":"Evaluate correctness of null handling.","question":"Functions assume non-null inputs. Risks?","think":"Consider null safety.","answer":"Add null checks. Use safe defaults and test invalid inputs."}
{"Instruction":"Assess modularity of monitoring.","question":"Observability inconsistent. Issues?","think":"Check reliability.","answer":"Standardize metrics. Centralize collection and integrate dashboards."}
{"Instruction":"Review correctness of concurrency.","question":"Shared state mutated. Risks?","think":"Consider race conditions.","answer":"Use immutability or synchronization. Add concurrency tests."}
{"Instruction":"Evaluate maintainability of dependency versions.","question":"Versions unpinned. Issues?","think":"Check reproducibility.","answer":"Pin versions. Audit regularly and automate updates."}
{"Instruction":"Assess correctness of resource allocation.","question":"Buffers allocated without size checks. Risks?","think":"Consider overflow.","answer":"Validate sizes. Handle failures gracefully and add stress tests."}
{"Instruction":"Review modularity of validation.","question":"Rules scattered. Issues?","think":"Check consistency.","answer":"Centralize validation. Document rules and add schema tests."}
{"Instruction":"Evaluate correctness of serialization formats.","question":"Format changes without migration. Risks?","think":"Consider compatibility.","answer":"Version formats. Provide migration tools and add compatibility tests."}
{"Instruction":"Assess maintainability of test data.","question":"Test data hardcoded. Issues?","think":"Check flexibility.","answer":"Use fixtures or generators. Document datasets and avoid duplication."}
{"Instruction":"Review correctness of numeric conversions.","question":"Implicit casts used. Risks?","think":"Consider precision loss.","answer":"Use explicit casts. Validate ranges and add edge case tests."}
{"Instruction":"Evaluate modularity of API clients.","question":"Calls hardcoded. Issues?","think":"Check duplication.","answer":"Refactor into reusable clients. Handle retries and document usage."}
{"Instruction":"Assess correctness of logging levels.","question":"All logs INFO. Issues?","think":"Check observability.","answer":"Use appropriate levels. Document strategy and monitor usage."}
{"Instruction":"Review maintainability of build artifacts.","question":"Artifacts stored manually. Issues?","think":"Check reproducibility.","answer":"Automate artifact storage. Use registries and document retention policies."}
{"Instruction":"Evaluate correctness of exception messages.","question":"Messages generic. Issues?","think":"Check debugging.","answer":"Provide context. Include identifiers and actionable hints."}
{"Instruction":"Assess modularity of persistence.","question":"Queries duplicated. Issues?","think":"Check maintainability.","answer":"Centralize queries. Document schema and add integration tests."}
{"Instruction":"Review correctness of string handling.","question":"Concatenation used for queries. Risks?","think":"Consider injection.","answer":"Use parameterized queries. Validate inputs and add malicious payload tests."}
{"Instruction":"Evaluate maintainability of CI pipelines.","question":"Scripts duplicated. Issues?","think":"Check consistency.","answer":"Centralize templates. Reuse workflows and document steps."}
{"Instruction":"Assess correctness of boundary conditions.","question":"Functions assume valid ranges. Risks?","think":"Consider runtime errors.","answer":"Add bounds checks. Validate inputs and include edge case tests."}
{"Instruction":"Review modularity of authentication.","question":"Logic embedded in controllers. Issues?","think":"Check separation.","answer":"Move auth into middleware. Document policies and add tests."}
{"Instruction":"Evaluate correctness of resource cleanup.","question":"Sockets not closed. Risks?","think":"Consider leaks.","answer":"Ensure closure. Use pools and monitor leaks."}
{"Instruction":"Assess maintainability of dependency injection.","question":"Dependencies instantiated directly. Issues?","think":"Check testability.","answer":"Use injection frameworks. Improve testability and reduce coupling."}
{"Instruction": "Review the Python function for readability and maintainability.", "question": "Does the function use clear naming and avoid side effects?", "think": "Focus on naming clarity, parameter immutability, and single responsibility.", "answer": "Rename ambiguous variables, avoid mutating inputs, and split the function into smaller helpers."}
{"Instruction": "Assess the JavaScript async code for error handling.", "question": "Are promises properly awaited and errors captured?", "think": "Check await usage, try/catch coverage, and fallback behavior.", "answer": "Wrap async calls in try/catch, return meaningful error messages, and ensure all promises are awaited."}
{"Instruction": "Evaluate SQL query safety and performance.", "question": "Is the query protected against injection and using indexes effectively?", "think": "Look for parameterization and WHERE clauses aligned with indexed columns.", "answer": "Use prepared statements, avoid string concatenation, and add composite indexes for frequent filters."}
{"Instruction": "Review Go concurrency patterns.", "question": "Are goroutines and channels used safely without leaks?", "think": "Check context cancellation, channel closure, and bounded worker pools.", "answer": "Propagate context, close channels after use, and limit goroutines with a worker pool."}
{"Instruction": "Check Java method for null-safety and defensive programming.", "question": "Does it validate inputs and avoid NullPointerExceptions?", "think": "Verify preconditions and use Optional or early returns.", "answer": "Add input validation, use Objects.requireNonNull, and return early on invalid states."}
{"Instruction": "Audit Python code for performance hotspots.", "question": "Are there unnecessary loops or repeated computations?", "think": "Identify redundant work and prefer vectorized or cached operations.", "answer": "Cache repeated results, replace nested loops with comprehensions, and use NumPy for heavy array operations."}
{"Instruction": "Inspect TypeScript types for correctness.", "question": "Do interfaces and generics prevent runtime type errors?", "think": "Ensure strict typing and avoid any casts.", "answer": "Enable strict mode, refine interfaces, and use generics to enforce type-safe APIs."}
{"Instruction": "Evaluate logging strategy in a microservice.", "question": "Is logging structured, contextual, and rate-limited?", "think": "Check correlation IDs, log levels, and sampling.", "answer": "Adopt structured logs with request IDs, standardize levels, and apply log sampling under load."}
{"Instruction": "Review Rust code for memory safety and lifetimes.", "question": "Are borrows valid and ownership clear?", "think": "Confirm lifetimes align and avoid unnecessary clones.", "answer": "Use references where possible, annotate lifetimes explicitly, and remove redundant clone calls."}
{"Instruction": "Assess error handling in a C# API controller.", "question": "Are exceptions mapped to consistent HTTP responses?", "think": "Check global filters and domain-specific error mapping.", "answer": "Add exception filters, standardize error payloads, and map domain errors to appropriate status codes."}
{"Instruction": "Check security of file upload handling.", "question": "Does the code validate file type, size, and storage path?", "think": "Prevent path traversal and enforce content-type checks.", "answer": "Whitelist MIME types, cap file size, sanitize filenames, and store uploads outside the web root."}
{"Instruction": "Evaluate test coverage and reliability.", "question": "Do unit tests cover edge cases and avoid flakiness?", "think": "Look for deterministic setup and boundary inputs.", "answer": "Add boundary tests, mock external dependencies, and remove timing-based assertions."}
{"Instruction": "Review caching strategy in a web application.", "question": "Are cache keys stable and invalidation correct?", "think": "Ensure consistent key generation and explicit TTLs.", "answer": "Use namespaced keys, set appropriate TTLs, and implement targeted invalidation on data changes."}
{"Instruction": "Inspect Python exception handling.", "question": "Are broad except clauses hiding bugs?", "think": "Prefer specific exceptions and re-raise when necessary.", "answer": "Catch specific exception types, log context, and re-raise critical errors to avoid silent failures."}
{"Instruction": "Assess database migration scripts.", "question": "Do migrations handle rollback and data integrity?", "think": "Check transactional safety and constraints.", "answer": "Wrap migrations in transactions, add foreign key constraints, and provide reversible steps."}
{"Instruction": "Review frontend accessibility.", "question": "Are components keyboard navigable and screen-reader friendly?", "think": "Check ARIA roles, focus management, and contrast.", "answer": "Add proper ARIA attributes, ensure focus states, and meet WCAG contrast ratios."}
{"Instruction": "Evaluate API pagination and limits.", "question": "Does the endpoint prevent over-fetching and support cursors?", "think": "Consider limit defaults and stable ordering.", "answer": "Set sane default limits, provide cursor-based pagination, and enforce consistent sort fields."}
{"Instruction": "Inspect input validation on server-side.", "question": "Are user inputs sanitized and validated before processing?", "think": "Apply whitelist validation and reject malformed data.", "answer": "Use schema validation, sanitize strings, and reject unexpected fields with clear errors."}
{"Instruction": "Review CI pipeline configuration.", "question": "Does the pipeline cache dependencies and fail fast?", "think": "Optimize steps and parallelize safely.", "answer": "Enable dependency caching, split jobs by stage, and fail fast on lint/test failures."}
{"Instruction": "Assess code for feature flag usage.", "question": "Are flags scoped and safe to remove later?", "think": "Avoid flag sprawl and dead code.", "answer": "Centralize flag definitions, add expirations, and clean up gated code after rollout."}
{"Instruction": "Review Python class design.", "question": "Does the class follow SOLID principles?", "think": "Check single responsibility, open/closed, and dependency inversion.", "answer": "Split responsibilities, use interfaces, and inject dependencies instead of hardcoding."}
{"Instruction": "Evaluate JavaScript DOM manipulation.", "question": "Is the code efficient and avoiding layout thrashing?", "think": "Look for repeated reflows and unnecessary DOM queries.", "answer": "Batch DOM updates, cache selectors, and use requestAnimationFrame for animations."}
{"Instruction": "Inspect C++ memory management.", "question": "Are pointers managed safely without leaks?", "think": "Check smart pointer usage and RAII compliance.", "answer": "Replace raw pointers with smart pointers and ensure destructors release resources."}
{"Instruction": "Assess Python data serialization.", "question": "Is JSON serialization secure and efficient?", "think": "Avoid unsafe eval and check encoding.", "answer": "Use json.dumps with safe defaults and validate schema before serialization."}
{"Instruction": "Review API authentication.", "question": "Is token handling secure and scoped?", "think": "Check expiration, refresh, and storage.", "answer": "Use short-lived tokens, refresh securely, and store only in secure contexts."}
{"Instruction": "Evaluate CSS architecture.", "question": "Is the stylesheet modular and maintainable?", "think": "Check BEM usage and avoid deep selectors.", "answer": "Adopt BEM naming, split files by component, and minimize global overrides."}
{"Instruction": "Inspect Python logging.", "question": "Are logs structured and sensitive data excluded?", "think": "Check log format and redaction.", "answer": "Use structured logging, redact PII, and configure log levels consistently."}
{"Instruction": "Review Node.js dependency usage.", "question": "Are dependencies minimal and updated?", "think": "Check for unused or vulnerable packages.", "answer": "Remove unused modules, update versions, and audit with npm audit."}
{"Instruction": "Assess Kubernetes deployment.", "question": "Are resource limits and probes configured?", "think": "Check CPU/memory limits and liveness/readiness probes.", "answer": "Set resource requests/limits, add probes, and configure autoscaling policies."}
{"Instruction": "Evaluate Python unit tests.", "question": "Do tests cover edge cases and exceptions?", "think": "Check boundary values and error paths.", "answer": "Add tests for invalid inputs, exceptions, and boundary conditions."}
{"Instruction": "Inspect Java thread usage.", "question": "Are threads managed safely without deadlocks?", "think": "Check synchronization and resource sharing.", "answer": "Use synchronized blocks carefully, prefer executors, and avoid nested locks."}
{"Instruction": "Review REST API design.", "question": "Are endpoints consistent and versioned?", "think": "Check naming conventions and versioning strategy.", "answer": "Use consistent resource names, include versioning, and follow HTTP semantics."}
{"Instruction": "Evaluate Python package structure.", "question": "Is the project organized for scalability?", "think": "Check module separation and init files.", "answer": "Organize by feature, add __init__.py, and avoid circular imports."}
{"Instruction": "Inspect JavaScript security.", "question": "Is user input sanitized against XSS?", "think": "Check DOM insertion and escaping.", "answer": "Escape HTML, use DOM APIs safely, and apply CSP headers."}
{"Instruction": "Review CI/CD secrets management.", "question": "Are secrets stored securely?", "think": "Check environment variables and vault usage.", "answer": "Store secrets in vaults, avoid plaintext, and rotate regularly."}
{"Instruction": "Evaluate Python performance.", "question": "Is code optimized for large datasets?", "think": "Check algorithm complexity and memory usage.", "answer": "Use generators, optimize algorithms, and avoid loading entire datasets into memory."}
{"Instruction": "Inspect Dockerfile.", "question": "Is the image small and secure?", "think": "Check base image and layer usage.", "answer": "Use minimal base images, combine RUN commands, and pin versions."}
{"Instruction": "Review GraphQL schema.", "question": "Is schema designed to prevent over-fetching?", "think": "Check field granularity and query limits.", "answer": "Define precise fields, enable query depth limits, and add rate limiting."}
{"Instruction": "Evaluate Python exception hierarchy.", "question": "Are custom exceptions meaningful and consistent?", "think": "Check inheritance and naming.", "answer": "Create domain-specific exceptions, inherit from Exception, and use descriptive names."}
{"Instruction": "Inspect caching in backend.", "question": "Is cache invalidation handled correctly?", "think": "Check TTLs and consistency.", "answer": "Set appropriate TTLs, invalidate on updates, and avoid stale data exposure."}
{"Instruction": "Review Python docstrings.", "question": "Are functions documented with clear purpose and parameters?", "think": "Check consistency, clarity, and examples.", "answer": "Add concise docstrings with parameter descriptions and usage examples for each function."}
{"Instruction": "Evaluate JavaScript event handling.", "question": "Are event listeners managed without memory leaks?", "think": "Check add/remove lifecycle and delegation.", "answer": "Use event delegation, remove listeners on cleanup, and avoid anonymous inline handlers."}
{"Instruction": "Inspect Ruby on Rails models.", "question": "Do models enforce validations and associations correctly?", "think": "Check presence, uniqueness, and foreign keys.", "answer": "Add validations for required fields, enforce uniqueness, and define proper associations."}
{"Instruction": "Review Python imports.", "question": "Are imports organized and avoiding circular dependencies?", "think": "Check import order and redundancy.", "answer": "Group imports by standard, third-party, and local, and remove unused imports."}
{"Instruction": "Evaluate Java exception handling.", "question": "Are exceptions caught at appropriate layers?", "think": "Check business vs infrastructure separation.", "answer": "Catch exceptions at service boundaries, log context, and rethrow domain-specific errors."}
{"Instruction": "Inspect PHP security.", "question": "Is user input sanitized against SQL injection?", "think": "Check query building and parameter binding.", "answer": "Use prepared statements, avoid concatenation, and validate input types."}
{"Instruction": "Review Python decorators.", "question": "Are decorators used appropriately for cross-cutting concerns?", "think": "Check logging, caching, and authorization.", "answer": "Apply decorators for reusable concerns and avoid mixing business logic with infrastructure."}
{"Instruction": "Evaluate Swift optionals.", "question": "Are optionals safely unwrapped?", "think": "Check force unwraps and nil handling.", "answer": "Use guard let, optional chaining, and avoid force unwraps."}
{"Instruction": "Inspect shell scripts.", "question": "Do scripts handle errors and portability?", "think": "Check exit codes and POSIX compliance.", "answer": "Add set -e, check exit codes, and use portable commands."}
{"Instruction": "Review Python concurrency.", "question": "Is multiprocessing or threading used safely?", "think": "Check shared state and synchronization.", "answer": "Use queues for communication, avoid global state, and prefer concurrent.futures."}
{"Instruction": "Evaluate Scala functional style.", "question": "Is immutability and pure functions enforced?", "think": "Check mutable vars and side effects.", "answer": "Replace vars with vals, use pure functions, and avoid side effects."}
{"Instruction": "Inspect HTML semantics.", "question": "Are semantic tags used for accessibility?", "think": "Check headings, landmarks, and alt attributes.", "answer": "Use <header>, <main>, <footer>, and provide alt text for images."}
{"Instruction": "Review Python error messages.", "question": "Are error messages informative and actionable?", "think": "Check clarity and context.", "answer": "Provide descriptive messages, include context, and avoid exposing sensitive details."}
{"Instruction": "Evaluate Rust error handling.", "question": "Are Result and Option used correctly?", "think": "Check unwraps and error propagation.", "answer": "Use match or ? operator, avoid unwrap, and propagate errors meaningfully."}
{"Instruction": "Inspect JavaScript build process.", "question": "Is bundling optimized for performance?", "think": "Check tree-shaking and minification.", "answer": "Enable tree-shaking, minify assets, and split bundles by route."}
{"Instruction": "Review Python configuration.", "question": "Are configs externalized and secure?", "think": "Check environment variables and defaults.", "answer": "Load configs from environment, provide safe defaults, and avoid hardcoding secrets."}
{"Instruction": "Evaluate C# LINQ queries.", "question": "Are queries efficient and readable?", "think": "Check deferred execution and clarity.", "answer": "Use method syntax for clarity, avoid nested queries, and leverage deferred execution."}
{"Instruction": "Inspect Python type hints.", "question": "Are type hints consistent and helpful?", "think": "Check function signatures and complex types.", "answer": "Add type hints for parameters and return values, and use typing module for collections."}
{"Instruction": "Review API rate limiting.", "question": "Is rate limiting enforced to prevent abuse?", "think": "Check per-user and global limits.", "answer": "Implement per-user quotas, global caps, and return 429 responses when exceeded."}
{"Instruction": "Evaluate CI pipeline notifications.", "question": "Are build failures communicated effectively?", "think": "Check alert channels and clarity.", "answer": "Send alerts to chat/email, include logs, and provide actionable failure context."}
{"Instruction": "Review Python context managers.", "question": "Are resources released properly after usage?", "think": "Check __enter__ and __exit__ implementations.", "answer": "Implement context managers with proper cleanup and use 'with' statements for resource handling."}
{"Instruction": "Evaluate JavaScript module exports.", "question": "Are modules structured for reusability and clarity?", "think": "Check default vs named exports.", "answer": "Use named exports for clarity, avoid mixing default and named, and group related functions."}
{"Instruction": "Inspect C# async/await usage.", "question": "Is asynchronous code avoiding deadlocks and blocking calls?", "think": "Check ConfigureAwait and Task.Run usage.", "answer": "Use async/await consistently, avoid blocking calls, and apply ConfigureAwait(false) in libraries."}
{"Instruction": "Review Python dictionary usage.", "question": "Are dictionaries used efficiently for lookups?", "think": "Check key existence and default values.", "answer": "Use dict.get with defaults, prefer defaultdict, and avoid repeated membership checks."}
{"Instruction": "Evaluate Java generic collections.", "question": "Are collections typed safely to avoid casting?", "think": "Check raw types and parameterization.", "answer": "Use generics consistently, avoid raw types, and prefer interfaces like List over concrete classes."}
{"Instruction": "Inspect Python file handling.", "question": "Are files opened and closed safely?", "think": "Check context manager usage.", "answer": "Use 'with open' blocks, specify encoding, and handle exceptions gracefully."}
{"Instruction": "Review JavaScript promises.", "question": "Are promises chained correctly to avoid nesting?", "think": "Check then/catch/finally usage.", "answer": "Chain promises with then/catch, avoid pyramid nesting, and use async/await for readability."}
{"Instruction": "Evaluate Python regex usage.", "question": "Are regex patterns efficient and readable?", "think": "Check unnecessary backtracking and clarity.", "answer": "Simplify patterns, use raw strings, and precompile regex for repeated use."}
{"Instruction": "Inspect Java annotations.", "question": "Are annotations applied consistently for frameworks?", "think": "Check dependency injection and validation.", "answer": "Apply annotations at correct scope, avoid duplication, and document custom annotations."}
{"Instruction": "Review Python list comprehensions.", "question": "Are comprehensions used instead of loops where appropriate?", "think": "Check readability and efficiency.", "answer": "Replace simple loops with comprehensions, keep expressions concise, and avoid nested comprehensions."}
{"Instruction": "Evaluate JavaScript error objects.", "question": "Are errors thrown with meaningful messages?", "think": "Check Error constructor usage.", "answer": "Throw new Error with descriptive messages and avoid silent failures."}
{"Instruction": "Inspect Python class inheritance.", "question": "Is inheritance used appropriately over composition?", "think": "Check base class responsibilities.", "answer": "Prefer composition over inheritance, ensure base classes are abstract, and avoid deep hierarchies."}
{"Instruction": "Review Java streams.", "question": "Are streams used efficiently for collections?", "think": "Check intermediate vs terminal operations.", "answer": "Use map/filter/reduce appropriately, avoid unnecessary collectors, and prefer parallel streams cautiously."}
{"Instruction": "Evaluate Python exception hierarchy.", "question": "Are exceptions grouped logically?", "think": "Check custom exception design.", "answer": "Create domain-specific exceptions, inherit from Exception, and avoid catching bare Exception."}
{"Instruction": "Inspect JavaScript async iterators.", "question": "Are async generators used correctly?", "think": "Check for-await-of usage.", "answer": "Use async generators for streams, handle errors inside loops, and close iterators properly."}
{"Instruction": "Review Python logging levels.", "question": "Are log levels applied consistently?", "think": "Check debug/info/warning/error usage.", "answer": "Use appropriate levels, avoid excessive debug logs, and escalate errors correctly."}
{"Instruction": "Evaluate Java immutability.", "question": "Are immutable objects enforced where needed?", "think": "Check final fields and defensive copies.", "answer": "Declare fields final, return defensive copies, and avoid setters in immutable classes."}
{"Instruction": "Inspect Python testing fixtures.", "question": "Are fixtures reusable and isolated?", "think": "Check pytest fixture scope.", "answer": "Define fixtures with proper scope, avoid side effects, and reuse across tests."}
{"Instruction": "Review JavaScript ES6 features.", "question": "Are modern syntax features used effectively?", "think": "Check let/const, arrow functions, and destructuring.", "answer": "Use const for immutables, arrow functions for callbacks, and destructuring for clarity."}
{"Instruction": "Evaluate Python async IO.", "question": "Is asyncio used correctly for concurrent tasks?", "think": "Check event loop and task management.", "answer": "Use asyncio.gather for concurrency, manage event loop properly, and handle cancellations."}
{"Instruction": "Review Python generator functions.", "question": "Are generators used to improve memory efficiency?", "think": "Check yield usage and lazy evaluation.", "answer": "Use generators for large datasets, replace list building with yield, and avoid unnecessary materialization."}
{"Instruction": "Evaluate JavaScript fetch API usage.", "question": "Is fetch used with proper error handling and timeouts?", "think": "Check response.ok and abort controllers.", "answer": "Check response.ok before parsing, use AbortController for timeouts, and handle network errors gracefully."}
{"Instruction": "Inspect Java static methods.", "question": "Are static methods applied only where appropriate?", "think": "Check utility vs instance responsibilities.", "answer": "Limit static methods to utilities, avoid stateful logic, and prefer instance methods for domain behavior."}
{"Instruction": "Review Python class properties.", "question": "Are properties used to encapsulate access safely?", "think": "Check getter/setter logic.", "answer": "Use @property for controlled access, validate in setters, and avoid exposing internal state directly."}
{"Instruction": "Evaluate JavaScript array methods.", "question": "Are map/filter/reduce used effectively?", "think": "Check readability and performance.", "answer": "Use map/filter for clarity, prefer reduce for aggregation, and avoid chaining with excessive complexity."}
{"Instruction": "Inspect Python exception logging.", "question": "Are exceptions logged with sufficient context?", "think": "Check stack traces and error codes.", "answer": "Log exceptions with stack trace, include context data, and avoid swallowing errors silently."}
{"Instruction": "Review Java enums.", "question": "Are enums used for fixed sets of constants?", "think": "Check type safety and readability.", "answer": "Use enums instead of integer constants, add descriptive names, and avoid magic numbers."}
{"Instruction": "Evaluate JavaScript async error handling.", "question": "Are async errors propagated correctly?", "think": "Check try/catch and promise rejection.", "answer": "Wrap async calls in try/catch, handle rejected promises, and propagate errors to higher layers."}
{"Instruction": "Inspect Python set usage.", "question": "Are sets used for uniqueness and fast membership checks?", "think": "Check list vs set operations.", "answer": "Use sets for membership tests, convert lists to sets for deduplication, and avoid repeated scans."}
{"Instruction": "Review Java interfaces.", "question": "Are interfaces designed for extensibility?", "think": "Check abstraction and implementation separation.", "answer": "Define interfaces for contracts, avoid leaking implementation details, and keep them cohesive."}
{"Instruction": "Evaluate Python string formatting.", "question": "Is f-string or format used consistently?", "think": "Check readability and performance.", "answer": "Use f-strings for clarity, avoid concatenation, and prefer format for complex templates."}
{"Instruction": "Inspect JavaScript closures.", "question": "Are closures used safely without memory leaks?", "think": "Check variable capture and scope.", "answer": "Avoid capturing unnecessary variables, release references, and use closures for encapsulation only."}
{"Instruction": "Review Python module organization.", "question": "Is code split into logical modules?", "think": "Check cohesion and import cycles.", "answer": "Group related functions, avoid circular imports, and keep modules small and focused."}
{"Instruction": "Evaluate Java logging framework usage.", "question": "Is logging configured consistently across modules?", "think": "Check log levels and appenders.", "answer": "Use a centralized logging config, set consistent levels, and avoid duplicate appenders."}
{"Instruction": "Inspect Python unittest usage.", "question": "Are tests isolated and repeatable?", "think": "Check setup/teardown and mocks.", "answer": "Use setUp/tearDown for isolation, mock external dependencies, and avoid shared state."}
{"Instruction": "Review JavaScript ES modules.", "question": "Are imports/exports structured for maintainability?", "think": "Check default vs named exports.", "answer": "Use named exports for clarity, avoid circular imports, and group related functions together."}
{"Instruction": "Evaluate Python lambda usage.", "question": "Are lambdas used appropriately for short functions?", "think": "Check readability and complexity.", "answer": "Use lambdas for concise callbacks, avoid complex logic, and prefer named functions for clarity."}
{"Instruction": "Inspect Java dependency injection.", "question": "Is DI framework used correctly?", "think": "Check constructor vs field injection.", "answer": "Prefer constructor injection, avoid static dependencies, and configure beans explicitly."}
{"Instruction": "Review Python JSON parsing.", "question": "Is JSON parsed safely and validated?", "think": "Check error handling and schema validation.", "answer": "Use json.loads with try/except, validate schema, and handle malformed input gracefully."}
{"Instruction": "Evaluate JavaScript async/await readability.", "question": "Is async/await improving clarity over promises?", "think": "Check nesting and error handling.", "answer": "Use async/await for sequential logic, handle errors with try/catch, and avoid mixing with .then chains."}
{"Instruction": "Review Python itertools usage.", "question": "Are itertools functions applied to simplify iteration?", "think": "Check product, chain, and groupby usage.", "answer": "Use itertools for complex iteration, replace nested loops, and improve readability with built-ins."}
{"Instruction": "Evaluate Java synchronized blocks.", "question": "Are synchronized blocks scoped minimally to avoid contention?", "think": "Check lock granularity and performance.", "answer": "Limit synchronized scope, avoid locking on this, and prefer ReentrantLock for flexibility."}
{"Instruction": "Inspect Python logging configuration.", "question": "Is logging configured centrally and consistently?", "think": "Check handlers, formatters, and propagation.", "answer": "Define a central logging config, set formatters, and disable propagation where unnecessary."}
{"Instruction": "Review JavaScript async data fetching.", "question": "Is data fetching optimized with concurrency?", "think": "Check Promise.all usage.", "answer": "Use Promise.all for parallel requests, handle errors collectively, and avoid sequential waits."}
{"Instruction": "Evaluate Python dataclass usage.", "question": "Are dataclasses used to simplify boilerplate?", "think": "Check field defaults and immutability.", "answer": "Use @dataclass for models, define default values, and set frozen=True for immutability."}
{"Instruction": "Inspect Java resource management.", "question": "Are resources closed properly after use?", "think": "Check try-with-resources usage.", "answer": "Use try-with-resources for streams, ensure proper closing, and avoid manual finally blocks."}
{"Instruction": "Review Python async context managers.", "question": "Are async resources managed safely?", "think": "Check async with usage.", "answer": "Use async with for async resources, ensure cleanup, and handle exceptions correctly."}
{"Instruction": "Evaluate JavaScript template literals.", "question": "Are template literals used for readability?", "think": "Check concatenation vs interpolation.", "answer": "Use template literals for string building, avoid concatenation, and include expressions inline."}
{"Instruction": "Inspect Python multiprocessing.", "question": "Is multiprocessing used safely with shared state?", "think": "Check Manager and Queue usage.", "answer": "Use multiprocessing.Manager for shared state, prefer Queue for communication, and avoid global variables."}
{"Instruction": "Review Java collections API.", "question": "Are collections chosen appropriately for use cases?", "think": "Check List, Set, Map usage.", "answer": "Use List for ordered data, Set for uniqueness, and Map for key-value pairs."}
{"Instruction": "Evaluate Python pathlib usage.", "question": "Is pathlib used instead of os.path?", "think": "Check readability and cross-platform support.", "answer": "Use pathlib.Path for file operations, prefer methods over string concatenation, and ensure portability."}
{"Instruction": "Inspect JavaScript async generators.", "question": "Are async generators used for streaming data?", "think": "Check for-await-of loops.", "answer": "Use async generators for streams, handle errors inside loops, and close iterators properly."}
{"Instruction": "Review Python typing module.", "question": "Is typing used for static analysis?", "think": "Check type hints and generics.", "answer": "Use typing.List and Dict, apply generics, and enable type checking tools like mypy."}
{"Instruction": "Evaluate Java switch expressions.", "question": "Are switch expressions used for concise branching?", "think": "Check readability and fall-through.", "answer": "Use switch expressions for clarity, avoid fall-through, and return values directly."}
{"Instruction": "Inspect Python subprocess usage.", "question": "Are subprocess calls secure and efficient?", "think": "Check shell=True and error handling.", "answer": "Avoid shell=True, capture output safely, and handle exceptions explicitly."}
{"Instruction": "Review JavaScript async iteration.", "question": "Is async iteration applied correctly?", "think": "Check for-await-of usage.", "answer": "Use for-await-of for async streams, handle errors gracefully, and close iterators properly."}
{"Instruction": "Evaluate Python functools usage.", "question": "Are functools utilities applied to simplify code?", "think": "Check lru_cache and partial usage.", "answer": "Use lru_cache for memoization, partial for pre-filling arguments, and reduce for aggregation."}
{"Instruction": "Inspect Java Optional usage.", "question": "Is Optional used to avoid null checks?", "think": "Check get vs orElse usage.", "answer": "Use Optional.orElse for defaults, avoid get without checks, and prefer Optional for return types."}
{"Instruction": "Review Python contextlib usage.", "question": "Is contextlib used to simplify resource management?", "think": "Check contextmanager decorator.", "answer": "Use @contextmanager for custom managers, simplify try/finally, and ensure cleanup logic."}
{"Instruction": "Evaluate JavaScript async/await patterns.", "question": "Are async/await patterns consistent across codebase?", "think": "Check readability and error handling.", "answer": "Use async/await for sequential logic, handle errors with try/catch, and avoid mixing with .then."}
{"Instruction": "Review Python asyncio tasks.", "question": "Are tasks managed without leaving unfinished coroutines?", "think": "Check task cancellation and cleanup.", "answer": "Use asyncio.create_task with proper cancellation, await all tasks, and handle exceptions explicitly."}
{"Instruction": "Evaluate Java record classes.", "question": "Are records used appropriately for immutable data?", "think": "Check concise syntax and immutability.", "answer": "Use records for simple data carriers, avoid setters, and ensure immutability of fields."}
{"Instruction": "Inspect Python logging handlers.", "question": "Are multiple handlers configured correctly?", "think": "Check file vs console output.", "answer": "Configure separate handlers for console and file, set levels independently, and avoid duplicate logs."}
{"Instruction": "Review JavaScript async queue handling.", "question": "Is concurrency controlled to avoid overload?", "think": "Check queue size and backpressure.", "answer": "Implement bounded queues, apply backpressure, and process tasks with controlled concurrency."}
{"Instruction": "Evaluate Python contextlib.suppress usage.", "question": "Is suppress used safely for exceptions?", "think": "Check exception scope.", "answer": "Use suppress for specific exceptions, avoid hiding critical errors, and document suppressed cases."}
{"Instruction": "Inspect Java thread pools.", "question": "Are thread pools sized correctly?", "think": "Check core vs max threads.", "answer": "Configure thread pools with appropriate sizes, avoid unbounded pools, and monitor usage metrics."}
{"Instruction": "Review Python itertools.groupby.", "question": "Is groupby used correctly for sorted data?", "think": "Check sorting before grouping.", "answer": "Sort data before groupby, use key functions consistently, and handle grouped results properly."}
{"Instruction": "Evaluate JavaScript async retry logic.", "question": "Is retry implemented with exponential backoff?", "think": "Check error handling and delays.", "answer": "Implement retries with exponential backoff, cap max attempts, and log failures clearly."}
{"Instruction": "Inspect Python weakref usage.", "question": "Are weak references used to avoid memory leaks?", "think": "Check cache and object lifecycle.", "answer": "Use weakref for caches, avoid strong references, and ensure objects are garbage collected."}
{"Instruction": "Review Java sealed classes.", "question": "Are sealed classes used to restrict inheritance?", "think": "Check permitted subclasses.", "answer": "Define sealed classes with permitted subclasses, enforce hierarchy, and document usage."}
{"Instruction": "Evaluate Python asyncio.gather usage.", "question": "Is gather used safely with error handling?", "think": "Check return_exceptions flag.", "answer": "Use asyncio.gather with return_exceptions=True when needed, and handle results carefully."}
{"Instruction": "Inspect JavaScript event loop.", "question": "Is event loop usage efficient?", "think": "Check microtasks vs macrotasks.", "answer": "Use microtasks for promises, macrotasks for timers, and avoid blocking the loop."}
{"Instruction": "Review Python ABC usage.", "question": "Are abstract base classes used for contracts?", "think": "Check inheritance and method enforcement.", "answer": "Define abstract methods, enforce implementation, and avoid instantiating abstract classes directly."}
{"Instruction": "Evaluate Java CompletableFuture usage.", "question": "Are futures chained correctly?", "think": "Check thenApply vs thenCompose.", "answer": "Use thenCompose for dependent futures, thenApply for transformations, and handle exceptions with exceptionally."}
{"Instruction": "Inspect Python heapq usage.", "question": "Is heapq used for efficient priority queues?", "think": "Check push/pop operations.", "answer": "Use heappush and heappop for queues, maintain heap invariants, and avoid manual sorting."}
{"Instruction": "Review JavaScript async cancellation.", "question": "Is cancellation supported in async flows?", "think": "Check AbortController usage.", "answer": "Use AbortController for fetch, propagate cancellation, and clean up resources properly."}
{"Instruction": "Evaluate Python enum usage.", "question": "Are enums used for fixed symbolic values?", "think": "Check readability and type safety.", "answer": "Use Enum for constants, define descriptive names, and avoid magic strings."}
{"Instruction": "Inspect Java try-with-resources.", "question": "Are resources closed automatically?", "think": "Check AutoCloseable implementation.", "answer": "Use try-with-resources for streams, implement AutoCloseable, and avoid manual closing."}
{"Instruction": "Review Python async timeouts.", "question": "Are timeouts applied to prevent hanging tasks?", "think": "Check asyncio.wait_for usage.", "answer": "Use asyncio.wait_for with explicit timeouts, handle TimeoutError, and log failures."}
{"Instruction": "Evaluate JavaScript async iteration pipelines.", "question": "Are pipelines structured for clarity?", "think": "Check generator composition.", "answer": "Compose async generators cleanly, handle errors at each stage, and avoid deeply nested loops."}
{"Instruction": "Review Python asyncio event loop.", "question": "Is the event loop managed without blocking calls?", "think": "Check run_until_complete and blocking I/O.", "answer": "Avoid blocking I/O, use run_until_complete sparingly, and prefer async functions for concurrency."}
{"Instruction": "Evaluate Java synchronized collections.", "question": "Are synchronized collections used safely in multithreaded contexts?", "think": "Check thread safety and alternatives.", "answer": "Use Collections.synchronized wrappers, prefer ConcurrentHashMap, and avoid manual synchronization."}
{"Instruction": "Inspect Python logging filters.", "question": "Are filters applied to control log output?", "think": "Check filter classes and handlers.", "answer": "Define custom filters, attach them to handlers, and reduce noise in logs."}
{"Instruction": "Review JavaScript async recursion.", "question": "Is recursion handled safely with async calls?", "think": "Check stack growth and termination.", "answer": "Use tail recursion or iterative loops, ensure termination conditions, and handle async errors properly."}
{"Instruction": "Evaluate Python asyncio shield usage.", "question": "Is shield used to protect tasks from cancellation?", "think": "Check asyncio.shield usage.", "answer": "Wrap critical tasks in asyncio.shield, handle cancellations gracefully, and avoid misuse."}
{"Instruction": "Inspect Java volatile fields.", "question": "Are volatile fields used correctly for visibility?", "think": "Check atomicity and synchronization.", "answer": "Use volatile for visibility, combine with synchronization for atomicity, and avoid misuse for compound actions."}
{"Instruction": "Review Python collections.Counter.", "question": "Is Counter used effectively for frequency counts?", "think": "Check updates and most_common usage.", "answer": "Use Counter for counting, update with iterables, and call most_common for top results."}
{"Instruction": "Evaluate JavaScript async pipelines.", "question": "Are async pipelines structured for clarity?", "think": "Check promise chaining and composition.", "answer": "Compose promises cleanly, avoid deeply nested chains, and use async/await for readability."}
{"Instruction": "Inspect Python asyncio.Semaphore.", "question": "Is semaphore used to limit concurrency?", "think": "Check acquire/release usage.", "answer": "Use Semaphore to bound concurrency, acquire before tasks, and release after completion."}
{"Instruction": "Review Java static imports.", "question": "Are static imports used for readability?", "think": "Check clarity vs ambiguity.", "answer": "Use static imports sparingly, avoid name clashes, and prefer explicit references for clarity."}
{"Instruction": "Evaluate Python contextlib.ExitStack.", "question": "Is ExitStack used for dynamic resource management?", "think": "Check multiple context managers.", "answer": "Use ExitStack for dynamic contexts, manage multiple resources, and ensure proper cleanup."}
{"Instruction": "Inspect JavaScript async iterables.", "question": "Are async iterables consumed correctly?", "think": "Check for-await-of usage.", "answer": "Use for-await-of loops, handle errors inside iteration, and close iterators properly."}
{"Instruction": "Review Python asyncio.Queue.", "question": "Is Queue used for safe task communication?", "think": "Check put/get usage.", "answer": "Use asyncio.Queue for producer-consumer, await put/get, and avoid blocking operations."}
{"Instruction": "Evaluate Java sealed interfaces.", "question": "Are sealed interfaces used to restrict implementations?", "think": "Check permitted implementors.", "answer": "Define sealed interfaces with permitted classes, enforce hierarchy, and document constraints."}
{"Instruction": "Inspect Python bisect module.", "question": "Is bisect used for sorted list insertion?", "think": "Check bisect_left and bisect_right usage.", "answer": "Use bisect for efficient insertion, maintain sorted lists, and avoid manual scanning."}
{"Instruction": "Review JavaScript async error propagation.", "question": "Are errors propagated consistently in async flows?", "think": "Check try/catch and rejection handling.", "answer": "Catch errors at each stage, propagate with throw, and avoid silent failures."}
{"Instruction": "Evaluate Python typing.Optional.", "question": "Is Optional used correctly for nullable values?", "think": "Check type hints and defaults.", "answer": "Use Optional for nullable parameters, provide defaults, and avoid misuse for non-nullable values."}
{"Instruction": "Inspect Java try-catch-finally.", "question": "Are try-catch-finally blocks structured correctly?", "think": "Check resource cleanup and exception handling.", "answer": "Use finally for cleanup, catch specific exceptions, and avoid swallowing errors."}
{"Instruction": "Review Python asyncio.run.", "question": "Is asyncio.run used appropriately to start event loops?", "think": "Check single entry point.", "answer": "Use asyncio.run as the main entry, avoid nested loops, and ensure proper shutdown."}
{"Instruction": "Evaluate JavaScript async concurrency.", "question": "Is concurrency managed without race conditions?", "think": "Check shared state and locks.", "answer": "Avoid shared mutable state, use atomic operations, and coordinate concurrency with proper patterns."}
{"Instruction": "Review Python asyncio streams.", "question": "Are streams used correctly for network communication?", "think": "Check reader/writer lifecycle.", "answer": "Use asyncio.open_connection, close streams after use, and handle exceptions gracefully."}
{"Instruction": "Evaluate Java functional interfaces.", "question": "Are functional interfaces applied consistently?", "think": "Check lambda and method references.", "answer": "Use functional interfaces for callbacks, prefer method references, and avoid anonymous classes."}
{"Instruction": "Inspect Python typing.Union.", "question": "Is Union used appropriately for multiple types?", "think": "Check type hints and readability.", "answer": "Use Union for multiple valid types, prefer Optional for nullable, and keep signatures clear."}
{"Instruction": "Review JavaScript async iterators with generators.", "question": "Are async generators composed effectively?", "think": "Check pipeline clarity.", "answer": "Compose async generators for streams, handle errors at each stage, and avoid deep nesting."}
{"Instruction": "Evaluate Python asyncio.Lock.", "question": "Is Lock used to prevent race conditions?", "think": "Check acquire/release usage.", "answer": "Use asyncio.Lock for shared state, acquire before critical sections, and release after completion."}
{"Instruction": "Inspect Java records with interfaces.", "question": "Are records implementing interfaces correctly?", "think": "Check immutability and contracts.", "answer": "Implement interfaces in records, keep them immutable, and avoid adding mutable fields."}
{"Instruction": "Review Python typing.NamedTuple.", "question": "Is NamedTuple used for structured data?", "think": "Check readability and immutability.", "answer": "Use NamedTuple for lightweight structures, define fields clearly, and prefer dataclass for complex cases."}
{"Instruction": "Evaluate JavaScript async error retries.", "question": "Is retry logic implemented with proper limits?", "think": "Check exponential backoff.", "answer": "Use exponential backoff, cap retries, and log failures for monitoring."}
{"Instruction": "Inspect Python asyncio.Event.", "question": "Is Event used for task synchronization?", "think": "Check set/wait usage.", "answer": "Use Event to signal tasks, call set when ready, and await wait in consumers."}
{"Instruction": "Review Java sealed hierarchies.", "question": "Are sealed hierarchies designed for clarity?", "think": "Check permitted subclasses.", "answer": "Define sealed hierarchies with clear permitted classes, enforce contracts, and document usage."}
{"Instruction": "Evaluate Python typing.Protocol.", "question": "Is Protocol used for structural typing?", "think": "Check duck typing and contracts.", "answer": "Use Protocol for structural typing, define required methods, and avoid over-specification."}
{"Instruction": "Inspect JavaScript async timeout handling.", "question": "Are timeouts applied to prevent hanging requests?", "think": "Check AbortController usage.", "answer": "Use AbortController for fetch, set timeouts, and handle abort errors properly."}
{"Instruction": "Review Python asyncio.Condition.", "question": "Is Condition used for complex synchronization?", "think": "Check wait/notify usage.", "answer": "Use Condition for multi-task coordination, call notify after state changes, and await wait properly."}
{"Instruction": "Evaluate Java Streams parallelism.", "question": "Is parallel stream usage safe and efficient?", "think": "Check thread safety and performance.", "answer": "Use parallel streams for CPU-bound tasks, avoid shared mutable state, and measure performance."}
{"Instruction": "Inspect Python typing.Literal.", "question": "Is Literal used for fixed values?", "think": "Check type hints.", "answer": "Use Literal for fixed symbolic values, improve type safety, and avoid magic strings."}
{"Instruction": "Review JavaScript async resource cleanup.", "question": "Are resources cleaned up after async operations?", "think": "Check finally blocks.", "answer": "Use try/finally for cleanup, close connections, and release resources after async tasks."}
{"Instruction": "Evaluate Python asyncio.TimeoutError handling.", "question": "Is TimeoutError handled gracefully?", "think": "Check wait_for usage.", "answer": "Catch TimeoutError, log context, and retry or fail gracefully."}
{"Instruction": "Inspect Java Optional chaining.", "question": "Is Optional chained effectively?", "think": "Check orElse and map usage.", "answer": "Use map for transformations, orElse for defaults, and avoid get without checks."}
{"Instruction": "Review Python typing.TypedDict.", "question": "Is TypedDict used for structured dicts?", "think": "Check field definitions.", "answer": "Define TypedDict for structured dicts, specify required fields, and use Optional for optional keys."}
{"Instruction": "Evaluate JavaScript async resource pooling.", "question": "Is resource pooling implemented correctly?", "think": "Check pool size and cleanup.", "answer": "Use bounded pools, release resources after use, and monitor pool utilization."}
{"Instruction": "Review Python asyncio.TaskGroup.", "question": "Is TaskGroup used to manage multiple tasks safely?", "think": "Check structured concurrency.", "answer": "Use TaskGroup to run tasks together, handle exceptions collectively, and ensure proper cancellation."}
{"Instruction": "Evaluate Java Stream collectors.", "question": "Are collectors used effectively for aggregation?", "think": "Check groupingBy and joining usage.", "answer": "Use Collectors.groupingBy for classification, joining for strings, and avoid manual loops."}
{"Instruction": "Inspect Python typing.Generic.", "question": "Is Generic used to enforce type safety?", "think": "Check parameterized classes.", "answer": "Define Generic classes with type variables, enforce type safety, and avoid raw types."}
{"Instruction": "Review JavaScript async module loading.", "question": "Is dynamic import used correctly?", "think": "Check lazy loading and error handling.", "answer": "Use import() for dynamic modules, handle errors gracefully, and avoid blocking main thread."}
{"Instruction": "Evaluate Python asyncio.current_task.", "question": "Is current_task used to track running tasks?", "think": "Check debugging and monitoring.", "answer": "Call asyncio.current_task for debugging, log task states, and avoid misuse in production."}
{"Instruction": "Inspect Java sealed records.", "question": "Are sealed records applied for restricted hierarchies?", "think": "Check immutability and permitted subclasses.", "answer": "Use sealed records for immutable hierarchies, define permitted subclasses, and enforce contracts."}
{"Instruction": "Review Python typing.Final.", "question": "Is Final used to prevent reassignment?", "think": "Check constants and immutability.", "answer": "Use Final for constants, enforce immutability, and avoid accidental reassignment."}
{"Instruction": "Evaluate JavaScript async resource disposal.", "question": "Are resources disposed after async operations?", "think": "Check finally blocks.", "answer": "Use try/finally for cleanup, close connections, and release resources after async tasks."}
{"Instruction": "Inspect Python asyncio.run_in_executor.", "question": "Is run_in_executor used for blocking tasks?", "think": "Check thread pool usage.", "answer": "Use run_in_executor for blocking I/O, configure thread pool size, and avoid CPU-bound tasks."}
{"Instruction": "Review Java annotations for validation.", "question": "Are validation annotations applied consistently?", "think": "Check @NotNull and @Size usage.", "answer": "Apply validation annotations on fields, enforce constraints, and integrate with validation frameworks."}
{"Instruction": "Evaluate Python typing.ClassVar.", "question": "Is ClassVar used correctly for class-level attributes?", "think": "Check dataclass usage.", "answer": "Use ClassVar for shared attributes, avoid instance-level misuse, and document intent clearly."}
{"Instruction": "Inspect JavaScript async iterator closing.", "question": "Are iterators closed properly after use?", "think": "Check return method.", "answer": "Call iterator.return when done, handle cleanup, and avoid resource leaks."}
{"Instruction": "Review Python asyncio.create_subprocess_exec.", "question": "Is subprocess execution handled safely?", "think": "Check pipes and error handling.", "answer": "Use create_subprocess_exec for subprocesses, capture stdout/stderr, and handle exceptions."}
{"Instruction": "Evaluate Java sealed interfaces with records.", "question": "Are sealed interfaces combined with records effectively?", "think": "Check hierarchy clarity.", "answer": "Combine sealed interfaces with records for immutability, enforce contracts, and restrict implementations."}
{"Instruction": "Inspect Python typing.TypeVar.", "question": "Is TypeVar used for generic functions?", "think": "Check type safety.", "answer": "Define TypeVar for generic functions, enforce type constraints, and improve readability."}
{"Instruction": "Review JavaScript async error logging.", "question": "Are async errors logged with context?", "think": "Check stack traces.", "answer": "Log async errors with stack traces, include context, and avoid silent failures."}
{"Instruction": "Evaluate Python asyncio.wait usage.", "question": "Is wait used correctly for multiple tasks?", "think": "Check return_when parameter.", "answer": "Use asyncio.wait with return_when=ALL_COMPLETED or FIRST_COMPLETED, and handle results properly."}
{"Instruction": "Inspect Java Optional.orElseThrow.", "question": "Is orElseThrow used for mandatory values?", "think": "Check exception clarity.", "answer": "Use orElseThrow for required values, throw meaningful exceptions, and avoid null checks."}
{"Instruction": "Review Python typing.Any.", "question": "Is Any used sparingly to avoid losing type safety?", "think": "Check type hints.", "answer": "Avoid overusing Any, prefer specific types, and use it only when unavoidable."}
{"Instruction": "Evaluate JavaScript async batching.", "question": "Is batching implemented to reduce network overhead?", "think": "Check grouped requests.", "answer": "Batch async requests together, reduce network calls, and handle grouped responses efficiently."}
{"Instruction": "Review Python asyncio.CancelledError handling.", "question": "Is CancelledError handled properly when tasks are cancelled?", "think": "Check try/except around await calls.", "answer": "Catch CancelledError explicitly, log cancellation, and ensure resources are released safely."}
{"Instruction": "Evaluate Java synchronized methods.", "question": "Are synchronized methods scoped correctly to avoid contention?", "think": "Check method-level vs block-level synchronization.", "answer": "Use synchronized blocks instead of whole methods, minimize lock scope, and avoid nested locks."}
{"Instruction": "Inspect Python typing.NewType usage.", "question": "Is NewType used to create distinct types?", "think": "Check type safety and readability.", "answer": "Use NewType for semantic distinctions, enforce type safety, and avoid confusion with base types."}
{"Instruction": "Review JavaScript async resource reuse.", "question": "Are resources reused efficiently across async calls?", "think": "Check pooling and lifecycle management.", "answer": "Implement resource pooling, reuse connections, and close resources after use."}
{"Instruction": "Evaluate Python asyncio.Future usage.", "question": "Is Future used correctly for awaiting results?", "think": "Check set_result and set_exception usage.", "answer": "Use Future for manual result handling, set results safely, and avoid blocking waits."}
{"Instruction": "Inspect Java sealed abstract classes.", "question": "Are sealed abstract classes used for restricted hierarchies?", "think": "Check permitted subclasses.", "answer": "Define sealed abstract classes with permitted subclasses, enforce hierarchy, and document usage."}
{"Instruction": "Review Python typing.Tuple.", "question": "Is Tuple used for fixed-length sequences?", "think": "Check type hints.", "answer": "Use Tuple for fixed-length sequences, specify element types, and avoid misuse for variable-length lists."}
{"Instruction": "Evaluate JavaScript async cleanup patterns.", "question": "Is cleanup performed after async operations?", "think": "Check finally usage.", "answer": "Use try/finally for cleanup, release resources, and ensure consistent state after async tasks."}
{"Instruction": "Inspect Python asyncio.StreamReader.", "question": "Is StreamReader used correctly for input streams?", "think": "Check read and readline usage.", "answer": "Use StreamReader.read for bulk data, readline for structured input, and handle EOF properly."}
{"Instruction": "Review Java Optional.map.", "question": "Is Optional.map used effectively for transformations?", "think": "Check chaining and readability.", "answer": "Use map for transformations, chain with flatMap when needed, and avoid null checks."}
{"Instruction": "Evaluate Python typing.Dict.", "question": "Is Dict used correctly for key-value mappings?", "think": "Check type hints.", "answer": "Use Dict with explicit key/value types, prefer TypedDict for structured data, and avoid Any."}
{"Instruction": "Inspect JavaScript async generator error handling.", "question": "Are errors handled inside async generators?", "think": "Check try/catch inside yield loops.", "answer": "Wrap yield loops in try/catch, propagate errors, and close generators properly."}
{"Instruction": "Review Python asyncio.StreamWriter.", "question": "Is StreamWriter used correctly for output streams?", "think": "Check write and drain usage.", "answer": "Use StreamWriter.write for output, call drain to flush, and close writer after use."}
{"Instruction": "Evaluate Java sealed hierarchies with interfaces.", "question": "Are sealed interfaces combined with classes effectively?", "think": "Check hierarchy clarity.", "answer": "Combine sealed interfaces with classes for restricted hierarchies, enforce contracts, and document usage."}
{"Instruction": "Inspect Python typing.Callable.", "question": "Is Callable used correctly for function signatures?", "think": "Check argument and return types.", "answer": "Use Callable with explicit argument and return types, avoid Any, and improve readability."}
{"Instruction": "Review JavaScript async error recovery.", "question": "Is error recovery implemented consistently?", "think": "Check retries and fallbacks.", "answer": "Implement retries with limits, provide fallback logic, and log errors for monitoring."}
{"Instruction": "Evaluate Python asyncio shield with gather.", "question": "Is shield combined with gather correctly?", "think": "Check cancellation handling.", "answer": "Wrap critical tasks in shield, use gather for concurrency, and handle cancellations gracefully."}
{"Instruction": "Inspect Java Optional.filter.", "question": "Is Optional.filter used to refine values?", "think": "Check predicate usage.", "answer": "Use filter to refine Optional values, chain with map, and avoid null checks."}
{"Instruction": "Review Python typing.Deque.", "question": "Is Deque used for efficient append/pop operations?", "think": "Check left/right operations.", "answer": "Use Deque for queues, prefer append/pop for efficiency, and avoid list for heavy operations."}
{"Instruction": "Evaluate JavaScript async batching with concurrency limits.", "question": "Is batching combined with concurrency limits?", "think": "Check Promise.allSettled usage.", "answer": "Batch requests with concurrency limits, use Promise.allSettled for results, and handle failures gracefully."}
{"Instruction": "Review Python asyncio.Task cancellation.", "question": "Are tasks cancelled safely without leaving dangling coroutines?", "think": "Check cancellation propagation.", "answer": "Call task.cancel, await task to finalize, and handle CancelledError properly."}
{"Instruction": "Evaluate Java Stream API flatMap.", "question": "Is flatMap used correctly for nested collections?", "think": "Check flattening and readability.", "answer": "Use flatMap to flatten nested collections, avoid manual loops, and keep pipelines clear."}
{"Instruction": "Inspect Python typing.Iterable.", "question": "Is Iterable used for generic iteration?", "think": "Check type hints.", "answer": "Use Iterable for generic iteration, prefer Sequence for indexable collections, and avoid Any."}
{"Instruction": "Review JavaScript async error boundaries.", "question": "Are error boundaries applied in async flows?", "think": "Check try/catch placement.", "answer": "Place try/catch around async calls, propagate errors, and log context for debugging."}
{"Instruction": "Evaluate Python asyncio.gather with return_exceptions.", "question": "Is return_exceptions used appropriately?", "think": "Check error handling strategy.", "answer": "Enable return_exceptions when partial success is acceptable, and handle exceptions individually."}
{"Instruction": "Inspect Java sealed hierarchies with enums.", "question": "Are enums integrated into sealed hierarchies?", "think": "Check clarity and restrictions.", "answer": "Combine enums with sealed classes for fixed sets, enforce hierarchy, and document usage."}
{"Instruction": "Review Python typing.TypeAlias.", "question": "Is TypeAlias used to simplify complex types?", "think": "Check readability.", "answer": "Define TypeAlias for complex type hints, improve readability, and avoid duplication."}
{"Instruction": "Evaluate JavaScript async resource lifecycle.", "question": "Is resource lifecycle managed across async calls?", "think": "Check initialization and disposal.", "answer": "Initialize resources before use, dispose after completion, and avoid leaks in async flows."}
{"Instruction": "Inspect Python asyncio.Barrier.", "question": "Is Barrier used for task synchronization?", "think": "Check participant count.", "answer": "Use Barrier for coordinated tasks, set participant count correctly, and handle broken barriers."}
{"Instruction": "Review Java Optional chaining with flatMap.", "question": "Is flatMap used to unwrap nested Optionals?", "think": "Check readability.", "answer": "Use flatMap to unwrap nested Optionals, chain transformations, and avoid null checks."}
{"Instruction": "Evaluate Python typing.Concatenate.", "question": "Is Concatenate used for callable signatures?", "think": "Check type hints.", "answer": "Use Concatenate to define callable signatures with prepended arguments, and improve type safety."}
{"Instruction": "Inspect JavaScript async error fallback.", "question": "Is fallback logic applied when async fails?", "think": "Check default values.", "answer": "Provide fallback values, retry with limits, and log failures for monitoring."}
{"Instruction": "Review Python asyncio.LifoQueue.", "question": "Is LifoQueue used for stack-like task management?", "think": "Check put/get usage.", "answer": "Use LifoQueue for stack behavior, await put/get, and avoid blocking operations."}
{"Instruction": "Evaluate Java sealed hierarchies with generics.", "question": "Are generics applied in sealed hierarchies?", "think": "Check type safety.", "answer": "Use generics in sealed hierarchies for type safety, enforce contracts, and avoid raw types."}
{"Instruction": "Inspect Python typing.TypedDict with total=False.", "question": "Is total=False used for optional keys?", "think": "Check field definitions.", "answer": "Define TypedDict with total=False for optional keys, specify required fields, and improve clarity."}
{"Instruction": "Review JavaScript async error aggregation.", "question": "Are multiple async errors aggregated correctly?", "think": "Check Promise.allSettled usage.", "answer": "Use Promise.allSettled to aggregate errors, handle results individually, and avoid silent failures."}
{"Instruction": "Evaluate Python asyncio.PriorityQueue.", "question": "Is PriorityQueue used for prioritized tasks?", "think": "Check put/get usage.", "answer": "Use PriorityQueue for prioritized tasks, assign numeric priorities, and handle tasks accordingly."}
{"Instruction": "Inspect Java Optional.ifPresentOrElse.", "question": "Is ifPresentOrElse used for branching?", "think": "Check readability.", "answer": "Use ifPresentOrElse for branching logic, provide defaults, and avoid null checks."}
{"Instruction": "Review Python typing.Annotated.", "question": "Is Annotated used to add metadata to types?", "think": "Check type hints.", "answer": "Use Annotated for metadata, integrate with validators, and improve documentation of type hints."}
{"Instruction": "Evaluate JavaScript async concurrency with worker pools.", "question": "Are worker pools used to manage concurrency?", "think": "Check pool size and task distribution.", "answer": "Implement worker pools, distribute tasks evenly, and monitor pool utilization."}
{"Instruction": "Review Python asyncio.create_task usage.", "question": "Is create_task used correctly to schedule coroutines?", "think": "Check task lifecycle and cancellation.", "answer": "Use create_task for concurrent coroutines, track tasks explicitly, and cancel them when no longer needed."}
{"Instruction": "Evaluate Java Stream reduce.", "question": "Is reduce used effectively for aggregation?", "think": "Check identity and accumulator usage.", "answer": "Provide identity values, use associative accumulators, and prefer built-in collectors when possible."}
{"Instruction": "Inspect Python typing.Self.", "question": "Is Self used correctly in class methods?", "think": "Check type hints for fluent APIs.", "answer": "Use Self for methods returning the same class, improve readability, and avoid ambiguous return types."}
{"Instruction": "Review JavaScript async debounce.", "question": "Is debounce implemented to limit rapid async calls?", "think": "Check timing and cancellation.", "answer": "Implement debounce with clear delay, cancel pending calls when new input arrives, and avoid race conditions."}
{"Instruction": "Evaluate Python asyncio.as_completed.", "question": "Is as_completed used to process tasks as they finish?", "think": "Check iteration and error handling.", "answer": "Use as_completed to handle results early, catch exceptions per task, and avoid blocking waits."}
{"Instruction": "Inspect Java sealed hierarchies with abstract records.", "question": "Are abstract records used effectively?", "think": "Check immutability and hierarchy clarity.", "answer": "Define abstract records for base contracts, enforce immutability, and restrict permitted subclasses."}
{"Instruction": "Review Python typing.TypeGuard.", "question": "Is TypeGuard used for narrowing types?", "think": "Check conditional logic.", "answer": "Use TypeGuard in helper functions, narrow types safely, and improve static analysis."}
{"Instruction": "Evaluate JavaScript async throttling.", "question": "Is throttling applied to control async call frequency?", "think": "Check interval and concurrency.", "answer": "Implement throttling with fixed intervals, limit concurrency, and ensure fairness across tasks."}
{"Instruction": "Inspect Python asyncio.Timeout context.", "question": "Is timeout context used to prevent hangs?", "think": "Check asyncio.timeout usage.", "answer": "Wrap tasks in asyncio.timeout, handle TimeoutError, and log failures clearly."}
{"Instruction": "Review Java Optional.stream.", "question": "Is Optional.stream used to integrate with streams?", "think": "Check readability.", "answer": "Use Optional.stream to convert values into streams, chain with other operations, and avoid null checks."}
{"Instruction": "Evaluate Python typing.FrozenSet.", "question": "Is FrozenSet used for immutable sets?", "think": "Check type hints.", "answer": "Use FrozenSet for immutable collections, prefer over set when immutability is required, and document usage."}
{"Instruction": "Inspect JavaScript async iterator pipelines.", "question": "Are pipelines structured for clarity and efficiency?", "think": "Check generator composition.", "answer": "Compose async iterators cleanly, handle errors at each stage, and avoid deep nesting."}
{"Instruction": "Review Python asyncio.run_until_complete.", "question": "Is run_until_complete used safely?", "think": "Check event loop lifecycle.", "answer": "Use run_until_complete for single entry points, avoid nested loops, and ensure proper shutdown."}
{"Instruction": "Evaluate Java sealed hierarchies with pattern matching.", "question": "Is pattern matching applied effectively?", "think": "Check switch expressions.", "answer": "Use pattern matching with sealed hierarchies, simplify branching, and avoid instanceof chains."}
{"Instruction": "Inspect Python typing.Counter.", "question": "Is Counter used for frequency analysis?", "think": "Check updates and most_common usage.", "answer": "Use Counter for frequency counts, update with iterables, and call most_common for top results."}
{"Instruction": "Review JavaScript async error suppression.", "question": "Is error suppression applied safely?", "think": "Check catch blocks.", "answer": "Suppress only expected errors, log suppressed cases, and avoid hiding critical failures."}
{"Instruction": "Evaluate Python asyncio.gather with shield.", "question": "Is shield used to protect critical tasks?", "think": "Check cancellation handling.", "answer": "Wrap critical tasks in shield, combine with gather, and handle cancellations gracefully."}
{"Instruction": "Inspect Java Optional chaining with map/filter.", "question": "Is chaining used effectively?", "think": "Check readability.", "answer": "Chain map and filter for transformations, avoid nested ifs, and keep pipelines concise."}
{"Instruction": "Review Python typing.TextIO.", "question": "Is TextIO used for file-like objects?", "think": "Check type hints.", "answer": "Use TextIO for file-like objects, specify read/write operations, and improve clarity in signatures."}
{"Instruction": "Evaluate JavaScript async concurrency with Promise.race.", "question": "Is Promise.race used correctly?", "think": "Check error handling.", "answer": "Use Promise.race for first-completed tasks, handle errors explicitly, and avoid unhandled rejections."}
{"Instruction": "Review Python asyncio.TaskGroup error handling.", "question": "Are exceptions inside TaskGroup handled consistently?", "think": "Check collective exception propagation.", "answer": "Catch exceptions from TaskGroup, log context, and ensure partial failures don’t block other tasks."}
{"Instruction": "Evaluate Java Stream peek usage.", "question": "Is peek used only for debugging and not side effects?", "think": "Check pipeline purity.", "answer": "Use peek for logging or debugging, avoid mutating state, and keep streams functional."}
{"Instruction": "Inspect Python typing.AsyncGenerator.", "question": "Is AsyncGenerator used correctly for async streams?", "think": "Check yield and await usage.", "answer": "Define AsyncGenerator with proper yield types, await inside loops, and close generators safely."}
{"Instruction": "Review JavaScript async Promise.allSettled.", "question": "Is Promise.allSettled used to handle mixed results?", "think": "Check success vs failure handling.", "answer": "Use Promise.allSettled to collect results, handle fulfilled and rejected separately, and log failures."}
{"Instruction": "Evaluate Python asyncio.create_subprocess_shell.", "question": "Is subprocess shell execution safe?", "think": "Check shell=True risks.", "answer": "Avoid shell=True unless necessary, sanitize inputs, and capture stdout/stderr securely."}
{"Instruction": "Inspect Java sealed hierarchies with pattern matching switch.", "question": "Is switch used effectively with sealed types?", "think": "Check exhaustive cases.", "answer": "Use switch expressions for sealed hierarchies, cover all permitted types, and avoid default fallbacks."}
{"Instruction": "Review Python typing.AsyncIterable.", "question": "Is AsyncIterable used for async iteration?", "think": "Check type hints.", "answer": "Use AsyncIterable for async streams, define element types, and improve clarity in signatures."}
{"Instruction": "Evaluate JavaScript async timeout with Promise.race.", "question": "Is Promise.race used to enforce timeouts?", "think": "Check abort handling.", "answer": "Wrap tasks with Promise.race against timeout, handle abort errors, and log failures clearly."}
{"Instruction": "Inspect Python asyncio.Semaphore fairness.", "question": "Is Semaphore used fairly across tasks?", "think": "Check acquire ordering.", "answer": "Use Semaphore with fair acquisition, release after completion, and avoid starvation."}
{"Instruction": "Review Java Optional chaining with orElseGet.", "question": "Is orElseGet used for lazy defaults?", "think": "Check performance.", "answer": "Use orElseGet for expensive defaults, avoid orElse when computation is costly, and improve efficiency."}
{"Instruction": "Evaluate Python typing.TypeVar with constraints.", "question": "Are TypeVars constrained correctly?", "think": "Check type safety.", "answer": "Define TypeVar with constraints, enforce type safety, and avoid raw types."}
{"Instruction": "Inspect JavaScript async generator closing with finally.", "question": "Is finally used to close async generators?", "think": "Check cleanup logic.", "answer": "Use try/finally inside async generators, release resources, and ensure proper closure."}
{"Instruction": "Review Python asyncio.wait_for usage.", "question": "Is wait_for used to enforce timeouts?", "think": "Check TimeoutError handling.", "answer": "Wrap tasks in wait_for, catch TimeoutError, and retry or fail gracefully."}
{"Instruction": "Evaluate Java sealed hierarchies with records and interfaces.", "question": "Are records and interfaces combined effectively?", "think": "Check immutability and contracts.", "answer": "Combine records with sealed interfaces, enforce immutability, and restrict implementations."}
{"Instruction": "Inspect Python typing.SupportsIndex.", "question": "Is SupportsIndex used for indexable objects?", "think": "Check type hints.", "answer": "Use SupportsIndex for indexable objects, improve clarity, and avoid misuse for non-indexable types."}
{"Instruction": "Review JavaScript async error handling with try/catch.", "question": "Is try/catch applied consistently in async functions?", "think": "Check readability.", "answer": "Wrap async calls in try/catch, log context, and propagate errors when necessary."}
{"Instruction": "Evaluate Python asyncio.shield with wait_for.", "question": "Is shield combined with wait_for correctly?", "think": "Check cancellation handling.", "answer": "Wrap critical tasks in shield, enforce timeouts with wait_for, and handle cancellations gracefully."}
{"Instruction": "Inspect Java Optional chaining with flatMap and filter.", "question": "Is chaining used effectively for transformations?", "think": "Check readability.", "answer": "Chain flatMap and filter for transformations, avoid nested ifs, and keep pipelines concise."}
{"Instruction": "Review Python typing.IO.", "question": "Is IO used for file-like objects?", "think": "Check type hints.", "answer": "Use IO for file-like objects, specify read/write operations, and improve clarity in signatures."}
{"Instruction": "Evaluate JavaScript async concurrency with Promise.any.", "question": "Is Promise.any used correctly?", "think": "Check error aggregation.", "answer": "Use Promise.any for first-success tasks, handle AggregateError, and avoid unhandled rejections."}
{"Instruction": "Review Python code for readability and maintainability.", "question": "What issues reduce readability in this Python module and how should they be fixed?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Use PEP 8 naming, add docstrings, break long functions, remove dead code, prefer explicit imports, and validate error handling with specific exceptions."}
{"Instruction": "Assess JavaScript async code for correctness and robustness.", "question": "How can this async/await logic be improved to avoid race conditions and unhandled rejections?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Wrap awaits in try/catch, return or await promises consistently, avoid mixing then/await, use Promise.all with error handling, and ensure cancellation or timeouts where appropriate."}
{"Instruction": "Evaluate Java class design for SOLID compliance.", "question": "Which SOLID violations exist in this Java service and what refactors address them?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Separate responsibilities, depend on interfaces, inject collaborators, remove god classes, and isolate side effects behind clear abstractions."}
{"Instruction": "Check C# code for null-safety and defensive programming.", "question": "What null-safety improvements are needed and how should guards be implemented?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Use nullable reference types, validate inputs early, throw specific exceptions, avoid null-return patterns, and prefer Option-like results or Try methods where suitable."}
{"Instruction": "Review TypeScript types for correctness and clarity.", "question": "How can the TypeScript types be tightened to prevent runtime errors?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Enable strict mode, replace any with precise unions/interfaces, use generics for collections, narrow types via guards, and prefer readonly for immutable data."}
{"Instruction": "Assess Go code for concurrency safety and resource management.", "question": "What concurrency risks exist and how should goroutines and channels be managed?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Avoid shared mutable state, use context for cancellation, close channels safely, check err returns, and limit goroutine lifetimes with clear ownership."}
{"Instruction": "Evaluate Rust code for ownership, borrowing, and error handling.", "question": "Where do ownership or lifetime issues appear and how should errors be handled idiomatically?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Prefer &mut over cloning when safe, use Result with anyhow/thiserror, avoid unwrap, leverage lifetimes explicitly, and encapsulate unsafe in minimal, audited blocks."}
{"Instruction": "Review PHP code for security and input validation.", "question": "What security gaps exist and how should input/output be sanitized?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Use prepared statements, escape output for HTML, validate inputs with filters, disable dangerous functions, and enforce CSRF tokens for state-changing requests."}
{"Instruction": "Assess Ruby code for idiomatic style and performance.", "question": "How can this Ruby code be made more idiomatic and efficient?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Use Enumerable methods over manual loops, freeze constants, avoid monkey-patching core classes, memoize expensive calls, and prefer symbols for keys."}
{"Instruction": "Evaluate Scala code for functional purity and testability.", "question": "What refactors improve functional style and make testing easier?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Favor immutable data, pure functions, explicit types, small composable modules, and dependency injection via constructors or typeclasses."}
{"Instruction": "Review Swift code for safety and API design.", "question": "How should optionals, error handling, and API naming be improved?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Use guard let for early exits, prefer Result or throws for errors, follow Swift API Design Guidelines, and avoid force unwraps or implicitly unwrapped optionals."}
{"Instruction": "Assess Kotlin code for null-safety and coroutine structure.", "question": "What changes improve null-safety and structured concurrency?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Use nullable types with safe calls, prefer sealed results, scope coroutines with SupervisorJob, handle exceptions in launch/async, and avoid global CoroutineScope."}
{"Instruction": "Evaluate SQL for correctness, performance, and safety.", "question": "How can these queries be optimized and secured against injection?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Use parameterized queries, add appropriate indexes, avoid SELECT *, analyze execution plans, and batch writes or use transactions for consistency."}
{"Instruction": "Review HTML/CSS for accessibility and maintainability.", "question": "What accessibility improvements and CSS structure changes are needed?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Add semantic tags and ARIA where necessary, ensure color contrast, provide focus states, use BEM or utility classes, and minimize specificity with modular styles."}
{"Instruction": "Assess Node.js service for reliability and observability.", "question": "How should logging, configuration, and error boundaries be improved?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Centralize structured logs, load config via env with validation, use process-level handlers for uncaught errors, implement retries/backoff, and expose health/readiness endpoints."}
{"Instruction": "Evaluate Dockerfiles for security and image size.", "question": "What changes reduce image size and improve security posture?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Use minimal base images, multi-stage builds, pin versions, drop root with USER, clean caches, and scan images for vulnerabilities."}
{"Instruction": "Review CI/CD pipeline for quality gates and reproducibility.", "question": "Which pipeline improvements ensure consistent builds and robust checks?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Pin tool versions, cache dependencies safely, run linters/tests/coverage, enforce artifact signing, and require approvals for protected branches."}
{"Instruction": "Assess API design for versioning and backward compatibility.", "question": "How should the API be structured to evolve without breaking clients?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Use semantic versioning, explicit error models, additive changes, deprecation policies, and contract tests with consumer-driven verification."}
{"Instruction": "Evaluate security in web applications across languages.", "question": "What cross-cutting security practices should be enforced?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Apply input validation, output encoding, least privilege, secure session management, rate limiting, and consistent dependency auditing with timely patching."}
{"Instruction": "Review documentation and comments for clarity and usefulness.", "question": "How can documentation better support onboarding and maintenance?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Provide concise README with setup/usage, document public APIs, explain design decisions, keep comments actionable, and automate docs generation where feasible."}
{"Instruction": "Review Perl code for maintainability and clarity.", "question": "How can this Perl script be refactored to improve readability and reduce legacy practices?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Replace implicit variables with named ones, use strict and warnings, modularize repeated logic, and prefer modern CPAN libraries."}
{"Instruction": "Assess Shell scripts for portability and safety.", "question": "What changes make this shell script more portable across environments?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Use POSIX-compliant syntax, quote variables, avoid hardcoded paths, check exit codes, and prefer env for shebang."}
{"Instruction": "Evaluate Haskell code for purity and type safety.", "question": "How can this Haskell function be improved for stronger type guarantees?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Use explicit type signatures, prefer pure functions, leverage Maybe/Either for errors, and avoid partial functions."}
{"Instruction": "Review R code for performance and reproducibility.", "question": "What improvements ensure this R script runs efficiently and reproducibly?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Vectorize operations, set seeds for randomness, document dependencies, prefer data.table/dplyr, and avoid global variables."}
{"Instruction": "Assess MATLAB code for efficiency and clarity.", "question": "How can this MATLAB function be optimized and documented?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Preallocate arrays, use built-in vectorized functions, add function headers, avoid nested loops, and validate inputs."}
{"Instruction": "Evaluate Dart code for Flutter best practices.", "question": "What changes improve state management and widget performance?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Use const constructors, prefer Provider/Bloc for state, minimize rebuilds, dispose controllers, and follow naming conventions."}
{"Instruction": "Review Elixir code for concurrency and fault tolerance.", "question": "How can this Elixir application be structured for resilience?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Use supervision trees, isolate processes, handle exits gracefully, prefer pattern matching, and leverage OTP behaviors."}
{"Instruction": "Assess C++ code for memory safety and modern practices.", "question": "What modern C++ features should replace unsafe patterns?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Use smart pointers, prefer RAII, apply constexpr, avoid raw new/delete, and leverage STL algorithms."}
{"Instruction": "Evaluate Objective-C code for modernization.", "question": "How can this Objective-C code be updated for better interoperability?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Adopt ARC, use properties instead of ivars, prefer lightweight generics, bridge with Swift, and remove manual retain/release."}
{"Instruction": "Review Fortran code for modernization and clarity.", "question": "What updates make this Fortran program easier to maintain?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Use modules over common blocks, add comments, prefer allocatable arrays, avoid goto, and enforce explicit typing."}
{"Instruction": "Assess COBOL code for readability and modernization.", "question": "How can COBOL code be refactored to align with modern standards?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Use meaningful variable names, modularize paragraphs, remove unused sections, document business rules, and prefer structured flow."}
{"Instruction": "Evaluate Lua code for simplicity and performance.", "question": "What improvements make this Lua script more efficient?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Avoid global variables, cache table lookups, use local functions, prefer ipairs/pairs correctly, and minimize string concatenation."}
{"Instruction": "Review Julia code for scientific computing best practices.", "question": "How can Julia code be optimized for numerical stability?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Use type-stable functions, prefer broadcasting, avoid global scope, leverage multiple dispatch, and validate floating-point precision."}
{"Instruction": "Assess C code for safety and maintainability.", "question": "What practices improve safety in this C program?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Check buffer boundaries, use const for immutables, prefer snprintf over sprintf, modularize headers, and validate return codes."}
{"Instruction": "Evaluate PowerShell scripts for automation reliability.", "question": "How can this PowerShell script be hardened for production use?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Use parameter validation, handle errors with try/catch, avoid plain text secrets, log actions, and prefer cmdlets over external tools."}
{"Instruction": "Review YAML/JSON configs for correctness and maintainability.", "question": "What changes ensure configuration files are safe and clear?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Validate schema, avoid duplication, document keys, use consistent indentation, and separate secrets into secure stores."}
{"Instruction": "Assess Terraform code for infrastructure best practices.", "question": "How can Terraform code be improved for scalability and safety?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Use modules, pin provider versions, apply variable validation, enable state locking, and document outputs."}
{"Instruction": "Evaluate Ansible playbooks for idempotency and clarity.", "question": "What changes improve Ansible playbook reliability?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Ensure tasks are idempotent, use roles, validate variables, avoid shell when modules exist, and document inventories."}
{"Instruction": "Review Kubernetes manifests for correctness and resilience.", "question": "What improvements make Kubernetes manifests safer and more scalable?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Set resource requests/limits, use liveness/readiness probes, prefer ConfigMaps/Secrets, avoid hardcoding, and apply RBAC policies."}
{"Instruction": "Assess Git usage for collaboration and history clarity.", "question": "How should Git practices be improved for team workflows?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Use meaningful commit messages, branch naming conventions, enforce code reviews, squash trivial commits, and tag releases consistently."}
{"Instruction": "Review Erlang code for concurrency and fault tolerance.", "question": "How can Erlang processes be structured to maximize reliability?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Use supervisors, isolate failures, prefer message passing, avoid shared state, and leverage OTP behaviors."}
{"Instruction": "Assess F# code for functional style and clarity.", "question": "What changes improve functional purity and readability in this F# module?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Favor immutability, use pattern matching, prefer pipelines, add explicit type annotations, and avoid side effects."}
{"Instruction": "Evaluate Nim code for safety and performance.", "question": "How can Nim code be improved for safer memory handling?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Use safe mode, prefer seq over raw arrays, validate inputs, avoid manual memory management, and modularize logic."}
{"Instruction": "Review Crystal code for idiomatic style.", "question": "What improvements make Crystal code more idiomatic and maintainable?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Use type annotations, prefer macros sparingly, leverage fibers for concurrency, document public APIs, and avoid global state."}
{"Instruction": "Assess Groovy code for readability and DSL usage.", "question": "How can Groovy scripts be improved for clarity and maintainability?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Use explicit closures, prefer builders for DSLs, validate inputs, avoid dynamic typing where strictness helps, and document tasks."}
{"Instruction": "Evaluate Smalltalk code for object-oriented purity.", "question": "What refactors improve Smalltalk code design?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Encapsulate state, prefer message passing, reduce method size, use meaningful selectors, and isolate responsibilities."}
{"Instruction": "Review Ada code for safety and modularity.", "question": "What practices improve Ada program reliability?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Use strong typing, modular packages, explicit contracts, exception handling, and avoid unchecked conversions."}
{"Instruction": "Assess Dart server-side code for scalability.", "question": "How can Dart server code be structured for scalability?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Use isolates for concurrency, prefer async I/O, modularize services, validate inputs, and log structured events."}
{"Instruction": "Evaluate ColdFusion code for modernization.", "question": "What changes modernize ColdFusion applications?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Use cfscript, modularize templates, validate inputs, prefer ORM for DB, and remove deprecated tags."}
{"Instruction": "Review Bash scripts for maintainability.", "question": "How can Bash scripts be improved for clarity and safety?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Quote variables, use functions, check exit codes, avoid eval, and document usage with comments."}
{"Instruction": "Assess Kotlin Multiplatform code for portability.", "question": "What practices improve Kotlin Multiplatform project structure?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Separate common and platform code, prefer expect/actual, validate dependencies, test across targets, and document APIs."}
{"Instruction": "Evaluate Assembly code for clarity and correctness.", "question": "How can Assembly routines be documented and structured better?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Add comments for registers, use labels consistently, modularize routines, validate stack usage, and avoid magic numbers."}
{"Instruction": "Review Clojure code for functional style.", "question": "What changes improve Clojure code readability and safety?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Use pure functions, prefer threading macros, validate inputs, avoid mutable refs, and document namespaces."}
{"Instruction": "Assess Visual Basic code for modernization.", "question": "How can Visual Basic code be updated for maintainability?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Use Option Strict, modularize forms, validate inputs, prefer .NET libraries, and remove legacy VB6 patterns."}
{"Instruction": "Evaluate Puppet manifests for reliability.", "question": "What improvements make Puppet manifests more robust?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Ensure idempotency, validate hiera data, modularize classes, avoid hardcoding, and document node roles."}
{"Instruction": "Review VHDL code for clarity and synthesis safety.", "question": "How can VHDL modules be improved for synthesis?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Use explicit signals, avoid latches, document timing, modularize entities, and validate testbenches."}
{"Instruction": "Assess Verilog code for correctness and readability.", "question": "What practices improve Verilog design clarity?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Use non-blocking assignments, document modules, avoid implicit nets, validate resets, and prefer parameterization."}
{"Instruction": "Evaluate Apex code for Salesforce best practices.", "question": "How can Apex code be improved for scalability?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Bulkify queries, use limits guards, prefer triggers over workflows, modularize services, and validate inputs."}
{"Instruction": "Review ABAP code for SAP standards.", "question": "What changes align ABAP code with SAP best practices?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Use modular function modules, validate inputs, avoid SELECT *, prefer CDS views, and document business logic."}
{"Instruction": "Review Hack code for correctness and type safety.", "question": "What improvements ensure Hack code uses strict typing effectively?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Enable strict mode, prefer Hack collections, validate nullable types, avoid dynamic typing, and document interfaces."}
{"Instruction": "Assess OCaml code for functional clarity.", "question": "How can OCaml modules be improved for readability and maintainability?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Use explicit type annotations, prefer pattern matching, modularize with functors, avoid mutable refs, and document signatures."}
{"Instruction": "Evaluate Kotlin DSL code for build scripts.", "question": "What practices improve Gradle Kotlin DSL readability?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Use extension functions, prefer typed accessors, modularize build logic, validate dependencies, and document tasks."}
{"Instruction": "Review Racket code for functional style.", "question": "How can Racket code be made more idiomatic?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Use higher-order functions, prefer let bindings, validate inputs, avoid mutation, and document modules."}
{"Instruction": "Assess Dart test code for reliability.", "question": "What changes improve Dart unit tests?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Use test groups, prefer mockito/fakes, validate async tests, avoid global state, and document expected outcomes."}
{"Instruction": "Evaluate Kotlin Android code for lifecycle safety.", "question": "What improvements ensure lifecycle-aware components?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Use ViewModel, prefer LiveData/Flow, dispose observers, validate context usage, and avoid leaks."}
{"Instruction": "Review Elm code for functional purity.", "question": "How can Elm code be structured for clarity?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Use pure functions, prefer union types, modularize updates, validate inputs, and document messages."}
{"Instruction": "Assess Haxe code for cross-platform clarity.", "question": "What practices improve Haxe project portability?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Use abstracts for type safety, modularize platform-specific code, validate inputs, and document APIs."}
{"Instruction": "Evaluate Kotlin scripting for automation.", "question": "How can Kotlin scripts be improved for maintainability?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Use functions, prefer typed variables, modularize logic, validate inputs, and document usage."}
{"Instruction": "Review Prolog code for clarity and correctness.", "question": "What improvements make Prolog rules easier to maintain?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Use meaningful predicate names, modularize facts, validate queries, avoid deep recursion, and document rules."}
{"Instruction": "Assess Scheme code for readability.", "question": "How can Scheme code be improved for clarity?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Use let/define consistently, prefer higher-order functions, validate inputs, avoid mutation, and document modules."}
{"Instruction": "Evaluate Kotlin server code for coroutine safety.", "question": "What practices improve coroutine usage in server apps?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Scope coroutines properly, handle exceptions, prefer structured concurrency, validate inputs, and avoid leaks."}
{"Instruction": "Review Julia package code for maintainability.", "question": "What changes improve Julia package design?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Use modules, prefer type-stable functions, document APIs, validate inputs, and add tests."}
{"Instruction": "Assess Kotlin DSL for configuration clarity.", "question": "How can Kotlin DSL configs be improved?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Use extension functions, modularize configs, validate inputs, prefer typed accessors, and document usage."}
{"Instruction": "Evaluate Kotlin Compose code for UI safety.", "question": "What practices improve Jetpack Compose code?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Use state hoisting, prefer immutable models, validate recompositions, modularize UI, and document components."}
{"Instruction": "Review Kotlin multiplatform tests for reliability.", "question": "How can tests be structured for multiplatform projects?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Use common test modules, validate platform-specific logic, prefer mocks, modularize test data, and document outcomes."}
{"Instruction": "Assess Kotlin Gradle plugins for maintainability.", "question": "What improvements make Gradle plugins easier to maintain?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Use extension functions, modularize tasks, validate inputs, prefer typed APIs, and document usage."}
{"Instruction": "Evaluate Kotlin Flow code for correctness.", "question": "How can Flow usage be improved?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Use catch for errors, prefer stateIn/shareIn, validate emissions, modularize collectors, and avoid leaks."}
{"Instruction": "Review Kotlin serialization code for safety.", "question": "What practices improve serialization reliability?", "think": "Provide a brief rationale without revealing step-by-step reasoning.", "answer": "Use explicit serializers, validate inputs, prefer sealed classes, modularize models, and document formats."}
{"Instruction": "Review Python code for readability issues", "question": "What is wrong with using single-letter variable names?", "think": "Single-letter names reduce clarity and hinder maintainability.", "answer": "Use descriptive variable names to improve readability and long-term code quality."}
{"Instruction": "Check JavaScript code for equality usage", "question": "Why is '==' problematic compared to '==='?", "think": "Loose equality can cause unexpected type coercion bugs.", "answer": "Always prefer '===' for strict equality to avoid hidden type conversions."}
{"Instruction": "Evaluate Java code for exception handling", "question": "What is the issue with catching generic Exception?", "think": "Catching all exceptions hides specific problems and complicates debugging.", "answer": "Catch specific exceptions to handle errors more precisely and safely."}
{"Instruction": "Inspect C++ code for memory management errors", "question": "Why is forgetting to delete dynamically allocated memory dangerous?", "think": "It leads to memory leaks and degraded performance over time.", "answer": "Always free allocated memory or use smart pointers to manage resources."}
{"Instruction": "Review C# code for async practices", "question": "What happens if 'await' is omitted in async calls?", "think": "The task may run without proper synchronization, causing race conditions.", "answer": "Always use 'await' to ensure asynchronous operations complete correctly."}
{"Instruction": "Check PHP code for security flaws", "question": "Why is directly concatenating user input into SQL queries unsafe?", "think": "It exposes the application to SQL injection attacks.", "answer": "Use prepared statements or parameterized queries to prevent SQL injection."}
{"Instruction": "Evaluate Rust code for ownership issues", "question": "What mistake occurs when borrowing mutable references twice?", "think": "Rust enforces borrowing rules to prevent data races.", "answer": "Avoid multiple mutable borrows; restructure code to respect ownership rules."}
{"Instruction": "Inspect Swift code for optionals misuse", "question": "Why is force-unwrapping optionals risky?", "think": "It can cause runtime crashes if the value is nil.", "answer": "Use optional binding or guard statements to safely unwrap values."}
{"Instruction": "Review Scala code for collection handling", "question": "What is the issue with using mutable collections excessively?", "think": "Mutable collections reduce predictability and thread safety.", "answer": "Prefer immutable collections to ensure safer and more predictable code."}
{"Instruction": "Check Ruby code for method naming conventions", "question": "Why is inconsistent method naming problematic?", "think": "It confuses developers and breaks idiomatic style.", "answer": "Follow Ruby naming conventions for clarity and consistency."}
{"Instruction": "Review Go code for error handling", "question": "Why is ignoring returned errors problematic?", "think": "Unchecked errors can cause silent failures and unstable behavior.", "answer": "Always check and handle errors explicitly to ensure reliable execution."}
{"Instruction": "Check Kotlin code for null safety", "question": "What happens if you bypass null checks?", "think": "It can lead to NullPointerExceptions at runtime.", "answer": "Use safe calls or the Elvis operator to handle null values properly."}
{"Instruction": "Evaluate TypeScript code for typing issues", "question": "Why is using 'any' type discouraged?", "think": "It removes type safety and defeats the purpose of TypeScript.", "answer": "Define explicit types or generics to maintain strong type safety."}
{"Instruction": "Inspect SQL code for performance problems", "question": "What is wrong with using SELECT * in queries?", "think": "It fetches unnecessary data and slows down performance.", "answer": "Specify only required columns to optimize query efficiency."}
{"Instruction": "Review Shell scripts for portability", "question": "Why is hardcoding absolute paths a mistake?", "think": "It reduces portability across different environments.", "answer": "Use environment variables or relative paths to improve portability."}
{"Instruction": "Check R code for reproducibility", "question": "What happens if you don't set a random seed?", "think": "Results vary between runs, making experiments non-reproducible.", "answer": "Set a seed with set.seed() to ensure reproducible outcomes."}
{"Instruction": "Evaluate MATLAB code for vectorization", "question": "Why is excessive use of for-loops inefficient?", "think": "Loops are slower compared to vectorized operations.", "answer": "Use built-in vectorized functions to improve performance."}
{"Instruction": "Inspect Perl code for readability", "question": "Why is excessive use of regex without comments problematic?", "think": "Complex regex becomes unreadable and hard to maintain.", "answer": "Document regex patterns or simplify them for clarity."}
{"Instruction": "Review Haskell code for purity", "question": "What is the issue with mixing pure and impure functions?", "think": "It breaks functional guarantees and complicates reasoning.", "answer": "Keep pure functions separate and isolate side effects with monads."}
{"Instruction": "Check Dart code for async handling", "question": "Why is forgetting to use 'await' in async functions risky?", "think": "It can cause incomplete execution and unexpected results.", "answer": "Always use 'await' to ensure proper sequencing of async operations."}
{"Instruction": "Review Elixir code for process handling", "question": "Why is blocking the main process problematic?", "think": "It prevents concurrent tasks from executing efficiently.", "answer": "Use lightweight processes and avoid blocking the main process to maintain concurrency."}
{"Instruction": "Check Clojure code for immutability practices", "question": "What happens if you rely too much on mutable Java interop?", "think": "It breaks functional guarantees and introduces side effects.", "answer": "Favor Clojure’s immutable data structures to preserve functional purity."}
{"Instruction": "Evaluate Lua code for global variable usage", "question": "Why is using undeclared globals risky?", "think": "Globals can be accidentally overwritten and cause hidden bugs.", "answer": "Declare locals explicitly to avoid polluting the global namespace."}
{"Instruction": "Inspect Fortran code for array indexing", "question": "What is the issue with mixing 0-based and 1-based indices?", "think": "It leads to off-by-one errors and incorrect calculations.", "answer": "Be consistent with array indexing conventions to avoid logic errors."}
{"Instruction": "Review Objective-C code for memory management", "question": "Why is forgetting to release objects dangerous?", "think": "It causes memory leaks and unstable applications.", "answer": "Use ARC or release objects properly to manage memory safely."}
{"Instruction": "Check Groovy code for dynamic typing pitfalls", "question": "What happens if you rely too much on dynamic typing?", "think": "It can cause runtime errors that static typing would prevent.", "answer": "Use explicit types when possible to catch errors earlier."}
{"Instruction": "Evaluate Erlang code for fault tolerance", "question": "Why is handling errors inside a process instead of letting it crash problematic?", "think": "It prevents supervisors from restarting faulty processes.", "answer": "Follow the 'let it crash' philosophy and rely on supervisors."}
{"Instruction": "Inspect Julia code for performance issues", "question": "What is wrong with type instability in functions?", "think": "It prevents the compiler from optimizing execution speed.", "answer": "Ensure functions return consistent types to improve performance."}
{"Instruction": "Review COBOL code for readability", "question": "Why is using cryptic variable names problematic?", "think": "It makes legacy code harder to maintain and understand.", "answer": "Use descriptive names to improve clarity and maintainability."}
{"Instruction": "Check PowerShell scripts for security", "question": "Why is running scripts without execution policy checks unsafe?", "think": "It allows malicious scripts to run unchecked.", "answer": "Set and enforce execution policies to prevent unauthorized script execution."}
{"Instruction": "Review Bash scripts for quoting issues", "question": "Why is failing to quote variables dangerous?", "think": "Unquoted variables can expand unexpectedly and break commands.", "answer": "Always quote variables to prevent word splitting and globbing problems."}
{"Instruction": "Check Visual Basic code for type safety", "question": "What happens if you rely on implicit type conversions?", "think": "It can cause subtle runtime errors and incorrect results.", "answer": "Use explicit type declarations to ensure predictable behavior."}
{"Instruction": "Evaluate Assembly code for maintainability", "question": "Why is using magic numbers problematic?", "think": "It makes code harder to understand and modify.", "answer": "Define constants with meaningful names to improve readability."}
{"Instruction": "Inspect Dart code for null safety", "question": "What is wrong with disabling sound null safety?", "think": "It reintroduces runtime crashes due to null values.", "answer": "Keep null safety enabled and handle nullable types properly."}
{"Instruction": "Review F# code for functional purity", "question": "Why is mixing mutable state with functional code risky?", "think": "It undermines immutability and introduces side effects.", "answer": "Favor immutable data and pure functions to maintain functional integrity."}
{"Instruction": "Check TCL code for error handling", "question": "What happens if you ignore return codes?", "think": "Scripts may silently fail without clear feedback.", "answer": "Always check return codes to ensure commands executed successfully."}
{"Instruction": "Evaluate Apex code for governor limits", "question": "Why is writing inefficient loops problematic?", "think": "It can exceed Salesforce governor limits and cause runtime failures.", "answer": "Optimize loops and queries to stay within platform limits."}
{"Instruction": "Inspect Haxe code for cross-platform issues", "question": "What is wrong with using platform-specific APIs directly?", "think": "It reduces portability and breaks builds on other targets.", "answer": "Use Haxe abstractions to maintain cross-platform compatibility."}
{"Instruction": "Review Scheme code for recursion", "question": "Why is deep recursion without tail-call optimization problematic?", "think": "It can cause stack overflows and crashes.", "answer": "Use tail recursion or iterative constructs to avoid stack issues."}
{"Instruction": "Check Crystal code for type inference", "question": "What happens if you rely too much on inferred types?", "think": "It may hide type mismatches and cause runtime surprises.", "answer": "Declare explicit types when clarity and safety are needed."}
{"Instruction": "Review Python async code for concurrency safety and resource cleanup.", "question": "Does the coroutine properly handle cancellation and ensure all tasks and file handles are closed?", "think": "Focus on cancellation propagation, shielded tasks, and finally blocks for cleanup.", "answer": "Add cancellation-aware try/except asyncio.CancelledError blocks, use asyncio.TaskGroup for structured concurrency, and ensure resources are closed in finally."}
{"Instruction": "Evaluate JavaScript promise chains for error handling and readability.", "question": "Are errors consistently caught and is the flow easy to follow?", "think": "Prefer async/await with centralized error handling and clear variable naming.", "answer": "Refactor to async/await, wrap calls in try/catch, and use a top-level error boundary; rename variables for intent clarity."}
{"Instruction": "Assess Java service for thread safety and immutability.", "question": "Do shared objects avoid race conditions and is state managed safely?", "think": "Check synchronized access, immutable DTOs, and use of concurrent collections.", "answer": "Make shared state immutable, use ConcurrentHashMap and Atomic types, and guard critical sections with synchronized or ReentrantLock."}
{"Instruction": "Review C# API controller for validation and null-safety.", "question": "Are inputs validated and nullable references handled correctly?", "think": "Use data annotations, FluentValidation, and nullable reference types.", "answer": "Add [Required]/[Range] attributes, enable nullable context, validate with FluentValidation, and return ProblemDetails for consistent errors."}
{"Instruction": "Check Rust code for ownership, lifetimes, and error propagation.", "question": "Are borrows safe and errors surfaced with context?", "think": "Prefer &mut over interior mutability, use anyhow/thiserror for context.", "answer": "Replace Rc<RefCell> with explicit borrowing, annotate lifetimes where needed, and use anyhow::Context to enrich error messages."}
{"Instruction": "Evaluate Go HTTP handlers for context usage and timeouts.", "question": "Do requests respect deadlines and cancel long-running operations?", "think": "Use request.Context(), set server timeouts, and propagate cancellation.", "answer": "Read ctx := r.Context(), check ctx.Done(), set Server timeouts, and pass ctx to DB calls to honor cancellation."}
{"Instruction": "Review SQL queries for performance and correctness.", "question": "Are indexes used effectively and are joins/selects minimal?", "think": "Check execution plans, avoid SELECT *, and ensure sargable predicates.", "answer": "Add composite indexes for filter/sort columns, replace SELECT * with explicit columns, and rewrite functions-on-column predicates to be sargable."}
{"Instruction": "Assess TypeScript types and API contracts.", "question": "Are types precise and aligned with runtime validation?", "think": "Use discriminated unions, generics, and zod/yup for validation.", "answer": "Define strict interfaces with readonly fields, use discriminated unions for variants, and validate payloads with zod schemas at boundaries."}
{"Instruction": "Review Python data processing for memory efficiency.", "question": "Does the pipeline stream data and avoid large in-memory structures?", "think": "Prefer generators, chunked I/O, and vectorized operations.", "answer": "Use iterators/generators, process files in chunks, leverage pandas vectorization, and avoid building full lists when a stream suffices."}
{"Instruction": "Evaluate Kotlin coroutines for structured concurrency.", "question": "Are scopes managed and exceptions handled predictably?", "think": "Use supervisorScope, CoroutineExceptionHandler, and cancel children on failure.", "answer": "Wrap concurrent tasks in supervisorScope, attach a CoroutineExceptionHandler, and ensure child jobs are cancelled on parent failure."}
{"Instruction": "Check Swift async code for main-thread UI safety.", "question": "Are UI updates dispatched to the main actor?", "think": "Use @MainActor and DispatchQueue.main.async for UI work.", "answer": "Annotate UI functions with @MainActor, hop to main queue for updates, and keep heavy work off the main thread with Task.detached."}
{"Instruction": "Review PHP code for security and input sanitation.", "question": "Are SQL queries parameterized and user input sanitized?", "think": "Use prepared statements and centralized sanitization.", "answer": "Replace string concatenation with PDO prepared statements, sanitize inputs via a single validation layer, and escape output to prevent XSS."}
{"Instruction": "Assess Ruby on Rails controllers for fat-controller smells.", "question": "Is business logic extracted into services and models?", "think": "Prefer PORO service objects and model scopes.", "answer": "Move business logic into service objects, use model scopes for query composition, and keep controllers thin with strong parameters."}
{"Instruction": "Evaluate React components for performance and re-renders.", "question": "Are props stable and expensive computations memoized?", "think": "Use useMemo/useCallback and keying strategy.", "answer": "Stabilize prop references, memoize heavy computations with useMemo, wrap handlers in useCallback, and avoid unnecessary context updates."}
{"Instruction": "Review Node.js app for graceful shutdown.", "question": "Do resources close on SIGINT/SIGTERM and in-flight requests finish?", "think": "Hook process signals and server.close with timeouts.", "answer": "Listen for SIGINT/SIGTERM, stop accepting new connections, await server.close, close DB pools, and enforce a max shutdown timeout."}
{"Instruction": "Check Django views for N+1 queries.", "question": "Are related objects prefetched and selected efficiently?", "think": "Use select_related/prefetch_related and annotate counts.", "answer": "Add select_related for FK relations, prefetch_related for M2M, and annotate aggregates to avoid per-row queries."}
{"Instruction": "Assess Terraform modules for reusability and safety.", "question": "Are variables typed, outputs documented, and state protected?", "think": "Use variable validation, version pinning, and remote state.", "answer": "Add type-checked variables with validation, pin provider versions, document outputs, and use remote state with locking to prevent corruption."}
{"Instruction": "Review CI pipeline for caching and reproducibility.", "question": "Are dependencies cached and builds deterministic?", "think": "Use lockfiles, cache keys, and immutable artifacts.", "answer": "Enable dependency caching with precise keys, enforce lockfiles, produce immutable build artifacts, and fail on unpinned versions."}
{"Instruction": "Evaluate API pagination and rate limiting.", "question": "Is pagination consistent and rate limits enforced fairly?", "think": "Use cursor-based pagination and token-bucket limits.", "answer": "Implement cursor-based pagination with stable ordering, expose limit/next cursors, and enforce token-bucket rate limiting with clear error responses."}
{"Instruction": "Check logging and observability across services.", "question": "Are logs structured and traces correlated?", "think": "Use JSON logs, correlation IDs, and metrics.", "answer": "Adopt structured JSON logging, propagate correlation IDs, instrument with metrics and tracing, and set log levels with sampling for high-volume paths."}
{"Instruction": "Review Scala code for functional purity and side-effect management.", "question": "Are functions pure and side effects isolated?", "think": "Check immutability, referential transparency, and use of IO monads.", "answer": "Ensure functions are pure, isolate side effects in IO monads, and prefer immutable data structures."}
{"Instruction": "Evaluate Haskell code for type safety and readability.", "question": "Do type signatures cover all functions and are monads used consistently?", "think": "Check explicit type annotations and consistent use of Maybe/Either.", "answer": "Add explicit type signatures, use Either for error handling, and prefer monad transformers for composition."}
{"Instruction": "Assess Perl scripts for maintainability and clarity.", "question": "Is variable naming clear and regex usage documented?", "think": "Avoid cryptic variable names and inline regex without comments.", "answer": "Rename variables descriptively, comment regex patterns, and modularize repeated logic into subroutines."}
{"Instruction": "Review Bash scripts for portability and error handling.", "question": "Are commands POSIX-compliant and errors trapped?", "think": "Check use of set -euo pipefail and portable syntax.", "answer": "Enable set -euo pipefail, replace bashisms with POSIX sh syntax, and trap errors with cleanup functions."}
{"Instruction": "Evaluate Julia code for numerical stability and performance.", "question": "Are floating-point operations stable and loops optimized?", "think": "Check use of broadcasting, type stability, and avoiding global variables.", "answer": "Use broadcasting instead of loops, ensure type stability, avoid globals, and leverage @inbounds for performance."}
{"Instruction": "Assess R scripts for reproducibility and efficiency.", "question": "Are random seeds set and vectorization used?", "think": "Check set.seed usage and avoid for-loops.", "answer": "Set random seeds with set.seed, replace loops with vectorized functions, and document package versions."}
{"Instruction": "Review Elixir code for concurrency and fault tolerance.", "question": "Are processes supervised and messages handled safely?", "think": "Check supervision trees and pattern matching in receive blocks.", "answer": "Use Supervisor trees, handle messages with exhaustive pattern matching, and monitor child processes."}
{"Instruction": "Evaluate C++ code for memory safety and RAII compliance.", "question": "Are resources managed with RAII and smart pointers?", "think": "Check raw new/delete usage and exception safety.", "answer": "Replace raw pointers with std::unique_ptr/std::shared_ptr, use RAII classes, and ensure exception-safe destructors."}
{"Instruction": "Assess Objective-C code for ARC compliance and readability.", "question": "Is memory managed automatically and naming consistent?", "think": "Check ARC usage and Apple naming conventions.", "answer": "Enable ARC, follow Apple naming guidelines, and replace manual retain/release with automatic memory management."}
{"Instruction": "Review Fortran code for modernization and clarity.", "question": "Are modern constructs used instead of legacy features?", "think": "Check use of modules, array operations, and free-form source.", "answer": "Replace COMMON blocks with modules, use array intrinsics, and adopt free-form source style."}
{"Instruction": "Evaluate COBOL programs for readability and modularity.", "question": "Is business logic separated into distinct sections?", "think": "Check division structure and variable naming.", "answer": "Organize code into IDENTIFICATION, ENVIRONMENT, DATA, PROCEDURE divisions, and use descriptive variable names."}
{"Instruction": "Assess Erlang code for distributed reliability.", "question": "Are processes linked and failures isolated?", "think": "Check process linking and supervision strategies.", "answer": "Link processes with supervisors, isolate failures with restart strategies, and use OTP behaviors."}
{"Instruction": "Review MATLAB scripts for performance and clarity.", "question": "Are vectorized operations used instead of loops?", "think": "Check preallocation and matrix operations.", "answer": "Preallocate arrays, replace loops with vectorized matrix operations, and document function inputs/outputs."}
{"Instruction": "Evaluate Dart code for null safety and Flutter best practices.", "question": "Are nullable types handled and widgets optimized?", "think": "Check null safety operators and widget rebuilds.", "answer": "Enable null safety, use const constructors for widgets, and minimize rebuilds with ValueNotifier."}
{"Instruction": "Assess Shell scripts for security and injection risks.", "question": "Are user inputs sanitized before execution?", "think": "Check variable expansion and command substitution.", "answer": "Quote all variable expansions, avoid eval, and validate user inputs before passing to commands."}
{"Instruction": "Review Kotlin DSL build scripts for maintainability.", "question": "Are dependencies versioned and tasks modular?", "think": "Check Gradle Kotlin DSL usage and dependency management.", "answer": "Pin dependency versions, modularize tasks, and use Gradle Kotlin DSL idioms for clarity."}
{"Instruction": "Evaluate Clojure code for immutability and REPL-driven design.", "question": "Are data structures immutable and functions composable?", "think": "Check persistent data structures and functional composition.", "answer": "Use persistent maps/vectors, compose functions with threading macros, and avoid mutable state."}
{"Instruction": "Assess F# code for functional style and type safety.", "question": "Are discriminated unions and pattern matching used effectively?", "think": "Check type inference and immutability.", "answer": "Define discriminated unions, use exhaustive pattern matching, and prefer immutable records."}
{"Instruction": "Review Lua scripts for readability and modularity.", "question": "Are global variables minimized and modules used?", "think": "Check use of local variables and require.", "answer": "Replace globals with locals, split code into modules, and document function responsibilities."}
{"Instruction": "Review Rust async code for deadlock risks.", "question": "Do async tasks share locks safely?", "think": "Check use of Mutex in async contexts.", "answer": "Replace std::sync::Mutex with tokio::sync::Mutex and avoid holding locks across await points."}
{"Instruction": "Evaluate Python logging setup for consistency.", "question": "Are loggers configured with proper levels and handlers?", "think": "Check root logger usage and formatter consistency.", "answer": "Configure module-specific loggers, set levels explicitly, and use consistent JSON formatters for observability."}
{"Instruction": "Assess Java Spring Boot service for dependency injection.", "question": "Are beans injected safely and lifecycle managed?", "think": "Check @Autowired usage and singleton scope.", "answer": "Prefer constructor injection, avoid field injection, and define bean scopes explicitly for clarity."}
{"Instruction": "Review Go code for error wrapping.", "question": "Are errors wrapped with context for debugging?", "think": "Check fmt.Errorf and errors.Join usage.", "answer": "Wrap errors with fmt.Errorf(\"...: %w\", err) and use errors.Join for multiple causes."}
{"Instruction": "Evaluate TypeScript React hooks for correctness.", "question": "Are dependencies listed properly in useEffect?", "think": "Check exhaustive-deps lint and stable references.", "answer": "List all dependencies in useEffect, memoize handlers with useCallback, and avoid stale closures."}
{"Instruction": "Assess C++ template code for readability.", "question": "Are templates overly complex and hard to maintain?", "think": "Check nested templates and SFINAE usage.", "answer": "Simplify templates with concepts, use type aliases, and document template parameters clearly."}
{"Instruction": "Review Ruby background jobs for reliability.", "question": "Are jobs retried safely and idempotent?", "think": "Check Sidekiq retry settings and job design.", "answer": "Design jobs to be idempotent, configure retry limits, and log failures with structured context."}
{"Instruction": "Evaluate PHP Laravel controllers for validation.", "question": "Are request inputs validated consistently?", "think": "Check FormRequest usage and centralized rules.", "answer": "Use FormRequest classes, define validation rules centrally, and return standardized error responses."}
{"Instruction": "Assess Swift Combine pipelines for cancellation.", "question": "Do subscriptions cancel properly to avoid leaks?", "think": "Check AnyCancellable storage and lifecycle.", "answer": "Store cancellables in a Set<AnyCancellable>, cancel on deinit, and avoid retain cycles."}
{"Instruction": "Review Kotlin Android code for lifecycle safety.", "question": "Are coroutines scoped to lifecycle owners?", "think": "Check viewModelScope and lifecycleScope usage.", "answer": "Launch coroutines in viewModelScope, cancel on lifecycle end, and avoid leaking references."}
{"Instruction": "Evaluate SQL migrations for safety.", "question": "Do migrations handle rollback and data integrity?", "think": "Check transaction usage and constraints.", "answer": "Wrap migrations in transactions, add foreign key constraints, and provide down scripts for rollback."}
{"Instruction": "Assess Node.js Express middleware for security.", "question": "Are headers set to prevent common attacks?", "think": "Check helmet usage and CSP headers.", "answer": "Enable helmet middleware, configure CSP headers, and set secure cookies with HttpOnly."}
{"Instruction": "Review Django REST API for pagination.", "question": "Is pagination implemented consistently across endpoints?", "think": "Check DRF pagination classes.", "answer": "Use LimitOffsetPagination or PageNumberPagination globally, and document pagination parameters."}
{"Instruction": "Evaluate Terraform code for secret management.", "question": "Are secrets stored securely and not hardcoded?", "think": "Check variable defaults and state exposure.", "answer": "Use environment variables or secret managers, avoid hardcoding, and enable state encryption."}
{"Instruction": "Assess CI/CD pipeline for parallelization.", "question": "Are jobs parallelized to reduce build time?", "think": "Check job dependencies and caching.", "answer": "Split independent jobs, enable caching, and run tests in parallel with matrix builds."}
{"Instruction": "Review API error responses for consistency.", "question": "Are errors returned with standard format?", "think": "Check HTTP status codes and JSON schema.", "answer": "Return errors with consistent JSON schema, include error codes, and use proper HTTP statuses."}
{"Instruction": "Evaluate JavaScript frontend for accessibility.", "question": "Are ARIA attributes and keyboard navigation supported?", "think": "Check semantic HTML and focus management.", "answer": "Add ARIA labels, ensure keyboard navigation, and manage focus for dynamic components."}
{"Instruction": "Assess Python unit tests for coverage.", "question": "Do tests cover edge cases and exceptions?", "think": "Check pytest coverage reports.", "answer": "Add tests for edge cases, assert exceptions, and measure coverage with pytest-cov."}
{"Instruction": "Review Rust error handling for clarity.", "question": "Are Result and Option used effectively?", "think": "Check unwrap usage and error propagation.", "answer": "Avoid unwrap, propagate errors with ?, and use Option combinators for clarity."}
{"Instruction": "Evaluate Scala Akka actors for supervision.", "question": "Are actors supervised and failures handled?", "think": "Check supervisor strategies.", "answer": "Define supervisor strategies, restart actors on failure, and log errors with context."}
{"Instruction": "Review Python decorators for clarity and maintainability.", "question": "Are decorators documented and reusable?", "think": "Check argument handling and docstrings.", "answer": "Add docstrings to decorators, ensure they handle *args/**kwargs, and reuse them across modules."}
{"Instruction": "Evaluate Java concurrency utilities for correctness.", "question": "Are ExecutorServices shut down properly?", "think": "Check shutdown hooks and thread leaks.", "answer": "Call shutdown() and awaitTermination(), avoid unbounded thread pools, and monitor thread usage."}
{"Instruction": "Assess JavaScript event listeners for memory leaks.", "question": "Are listeners removed when components unmount?", "think": "Check addEventListener/removeEventListener usage.", "answer": "Detach listeners in cleanup functions, use once:true when appropriate, and avoid global listeners."}
{"Instruction": "Review C# LINQ queries for efficiency.", "question": "Are queries evaluated lazily and optimized?", "think": "Check deferred execution and ToList calls.", "answer": "Avoid unnecessary ToList(), use Select/Where efficiently, and prefer joins over nested loops."}
{"Instruction": "Evaluate Rust traits for abstraction quality.", "question": "Do traits capture behavior without overcomplication?", "think": "Check trait bounds and blanket impls.", "answer": "Simplify trait bounds, avoid overlapping blanket impls, and document trait responsibilities."}
{"Instruction": "Assess Go channels for deadlock risks.", "question": "Are channels closed safely and used correctly?", "think": "Check send/receive patterns and select usage.", "answer": "Close channels in producers, avoid double close, and use select with default to prevent blocking."}
{"Instruction": "Review SQL stored procedures for readability.", "question": "Are procedures modular and documented?", "think": "Check naming conventions and comments.", "answer": "Use descriptive names, add inline comments, and split large procedures into smaller ones."}
{"Instruction": "Evaluate TypeScript generics for clarity.", "question": "Are generics constrained and documented?", "think": "Check type parameter bounds and readability.", "answer": "Add constraints to generics, document type parameters, and avoid overly complex generic signatures."}
{"Instruction": "Assess Kotlin extension functions for maintainability.", "question": "Are extensions used appropriately?", "think": "Check scope and readability.", "answer": "Use extensions for domain-specific helpers, avoid polluting global scope, and document usage."}
{"Instruction": "Review Swift optionals for safety.", "question": "Are optionals unwrapped safely?", "think": "Check force unwraps and nil handling.", "answer": "Replace force unwraps with guard/if let, provide default values, and handle nil gracefully."}
{"Instruction": "Evaluate PHP Composer dependencies for security.", "question": "Are dependencies pinned and audited?", "think": "Check composer.lock and audit tools.", "answer": "Pin versions in composer.json, commit composer.lock, and run composer audit regularly."}
{"Instruction": "Assess Ruby gems for version management.", "question": "Are gem versions locked and updated?", "think": "Check Gemfile.lock and dependency updates.", "answer": "Lock gem versions, update regularly with bundle update, and audit with bundler-audit."}
{"Instruction": "Review Node.js package.json for maintainability.", "question": "Are scripts organized and dependencies managed?", "think": "Check devDependencies and script clarity.", "answer": "Separate devDependencies, use descriptive script names, and remove unused packages."}
{"Instruction": "Evaluate Django models for normalization.", "question": "Are models normalized and relationships clear?", "think": "Check foreign keys and redundancy.", "answer": "Normalize models, define clear foreign keys, and avoid redundant fields."}
{"Instruction": "Assess Terraform variable usage for clarity.", "question": "Are variables typed and documented?", "think": "Check variable blocks and descriptions.", "answer": "Add type constraints, provide descriptions, and avoid unused variables."}
{"Instruction": "Review CI pipeline secrets management.", "question": "Are secrets stored securely?", "think": "Check environment variables and vault usage.", "answer": "Store secrets in vaults, inject via environment variables, and avoid plaintext in configs."}
{"Instruction": "Evaluate API versioning strategy.", "question": "Is versioning consistent across endpoints?", "think": "Check URL patterns and backward compatibility.", "answer": "Use semantic versioning in URLs, maintain backward compatibility, and document changes."}
{"Instruction": "Assess frontend CSS for maintainability.", "question": "Is CSS modular and scoped?", "think": "Check BEM naming and scoping.", "answer": "Use BEM conventions, scope styles to components, and avoid global overrides."}
{"Instruction": "Review logging configuration for scalability.", "question": "Are logs rotated and stored efficiently?", "think": "Check log rotation and storage policies.", "answer": "Enable log rotation, compress old logs, and centralize storage with ELK or similar."}
{"Instruction": "Evaluate microservices communication for resilience.", "question": "Are retries and timeouts configured?", "think": "Check HTTP clients and circuit breakers.", "answer": "Configure retries with backoff, set timeouts, and use circuit breakers for resilience."}
{"Instruction": "Review Python context managers for resource safety.", "question": "Are resources released properly after use?", "think": "Check __enter__/__exit__ implementations.", "answer": "Implement __exit__ to release resources, use contextlib for reusable managers, and test cleanup paths."}
{"Instruction": "Evaluate Java annotations for consistency.", "question": "Are annotations applied uniformly across layers?", "think": "Check @Transactional, @Nullable usage.", "answer": "Apply annotations consistently, document their intent, and avoid mixing framework-specific and custom annotations."}
{"Instruction": "Assess JavaScript async iterators for correctness.", "question": "Are async generators consumed safely?", "think": "Check for-await-of loops.", "answer": "Use for-await-of, handle errors with try/catch, and close iterators explicitly when needed."}
{"Instruction": "Review C# async streams for cancellation.", "question": "Do async streams respect cancellation tokens?", "think": "Check IAsyncEnumerable and WithCancellation.", "answer": "Pass cancellation tokens to async streams, propagate cancellation, and dispose enumerators properly."}
{"Instruction": "Evaluate Rust macros for readability.", "question": "Are macros documented and safe?", "think": "Check hygiene and clarity.", "answer": "Document macro usage, ensure hygienic identifiers, and prefer functions when macros add complexity."}
{"Instruction": "Assess Go struct tags for consistency.", "question": "Are JSON tags aligned with API contracts?", "think": "Check field naming and omitempty.", "answer": "Use consistent JSON tags, apply omitempty where appropriate, and match API schema."}
{"Instruction": "Review SQL indexes for redundancy.", "question": "Are duplicate indexes avoided?", "think": "Check overlapping columns.", "answer": "Remove redundant indexes, consolidate multi-column indexes, and monitor query plans."}
{"Instruction": "Evaluate TypeScript enums for clarity.", "question": "Are enums descriptive and type-safe?", "think": "Check string vs numeric enums.", "answer": "Prefer string enums for readability, document values, and avoid mixing enum types."}
{"Instruction": "Assess Kotlin sealed classes for exhaustiveness.", "question": "Are sealed hierarchies matched exhaustively?", "think": "Check when expressions.", "answer": "Use sealed classes for closed hierarchies, ensure exhaustive when branches, and document variants."}
{"Instruction": "Review Swift protocols for abstraction.", "question": "Do protocols define minimal contracts?", "think": "Check protocol segregation.", "answer": "Define protocols with minimal requirements, avoid bloated contracts, and extend with default implementations."}
{"Instruction": "Evaluate PHP error handling for robustness.", "question": "Are exceptions caught and logged?", "think": "Check try/catch blocks.", "answer": "Catch exceptions at boundaries, log with context, and avoid suppressing errors silently."}
{"Instruction": "Assess Ruby RSpec tests for clarity.", "question": "Are test descriptions meaningful?", "think": "Check it/describe blocks.", "answer": "Write descriptive it blocks, group related tests in describe, and avoid redundant assertions."}
{"Instruction": "Review Node.js async error handling.", "question": "Are async errors propagated correctly?", "think": "Check promise chains and async/await.", "answer": "Use try/catch with async/await, return rejected promises, and avoid unhandled rejections."}
{"Instruction": "Evaluate Django signals for maintainability.", "question": "Are signals overused instead of explicit calls?", "think": "Check decoupling and clarity.", "answer": "Limit signals to cross-cutting concerns, prefer explicit function calls, and document signal usage."}
{"Instruction": "Assess Terraform outputs for clarity.", "question": "Are outputs documented and named clearly?", "think": "Check output blocks.", "answer": "Name outputs descriptively, add descriptions, and avoid exposing sensitive values."}
{"Instruction": "Review CI pipeline caching strategy.", "question": "Is caching effective and safe?", "think": "Check cache keys and invalidation.", "answer": "Use precise cache keys, invalidate on dependency changes, and avoid caching sensitive data."}
{"Instruction": "Evaluate API authentication flows.", "question": "Are tokens validated and refreshed securely?", "think": "Check JWT expiration and refresh.", "answer": "Validate JWTs, enforce expiration, implement refresh tokens securely, and log authentication events."}
{"Instruction": "Assess frontend JavaScript bundling.", "question": "Is bundling optimized for performance?", "think": "Check tree-shaking and code splitting.", "answer": "Enable tree-shaking, split bundles by route, and compress assets with gzip/brotli."}
{"Instruction": "Review logging levels for consistency.", "question": "Are log levels used appropriately?", "think": "Check debug/info/warn/error usage.", "answer": "Use debug for development, info for normal ops, warn for recoverable issues, and error for failures."}
{"Instruction": "Evaluate microservices API contracts.", "question": "Are contracts versioned and documented?", "think": "Check OpenAPI specs.", "answer": "Maintain OpenAPI specs, version contracts, and publish documentation for consumers."}
{"Instruction":"Review the code for readability and maintainability without assuming a specific language.","question":"The function mixes business logic with I/O operations. What should be improved?","think":"Identify separation-of-concerns issues and propose modularization.","answer":"Separate business logic from I/O by introducing clear layers (e.g., service vs. adapter). Extract pure logic into independent functions or classes, inject I/O dependencies, and add unit tests for the business layer."}
{"Instruction":"Analyze the code structure and suggest architectural improvements.","question":"A single class handles validation, persistence, and formatting output. What is the problem?","think":"Detect Single Responsibility Principle violations.","answer":"The class violates the Single Responsibility Principle. Split responsibilities into dedicated components such as a validator, repository, and presenter to improve testability and long-term maintainability."}
{"Instruction":"Evaluate the performance characteristics of the given code.","question":"A loop performs repeated database queries inside each iteration. How can this be optimized?","think":"Identify unnecessary repeated expensive operations.","answer":"Move database access outside the loop and batch queries where possible. Cache results or preload required data to reduce I/O overhead and improve overall performance."}
{"Instruction":"Review the code for potential refactoring opportunities.","question":"Multiple functions contain nearly identical logic with small variations. What should be done?","think":"Look for code duplication and abstraction opportunities.","answer":"Extract the shared logic into a reusable function or module and parameterize the differences. This reduces duplication, simplifies changes, and lowers the risk of inconsistent behavior."}
{"Instruction":"Assess the error handling strategy used in the code.","question":"Errors are silently ignored in several catch blocks. Why is this an issue?","think":"Consider observability and debugging concerns.","answer":"Silently ignoring errors hides failures and makes debugging difficult. Log errors with sufficient context, propagate them when appropriate, and define clear error-handling policies."}
{"Instruction":"Review the code for clarity and developer experience.","question":"Variable names are short and ambiguous (e.g., x, tmp, data1). What is the impact?","think":"Evaluate readability and cognitive load.","answer":"Ambiguous names increase cognitive load and slow understanding. Use descriptive, intention-revealing names that communicate purpose, domain meaning, and expected usage."}
{"Instruction":"Analyze the function design.","question":"A function has more than ten parameters. What problems might this cause?","think":"Identify API usability and maintainability risks.","answer":"Too many parameters reduce readability and increase misuse risk. Group related parameters into objects, apply the Parameter Object pattern, or split the function into smaller units."}
{"Instruction":"Evaluate the code for testability.","question":"Core logic directly instantiates external dependencies. Why is this problematic?","think":"Check dependency management and test isolation.","answer":"Direct instantiation tightly couples logic to implementations. Use dependency injection or abstractions to allow mocking and isolated unit testing."}
{"Instruction":"Review the code from a performance perspective.","question":"The same expensive computation is repeated multiple times with identical inputs. How should this be handled?","think":"Look for memoization or caching opportunities.","answer":"Cache or memoize the computation results when inputs are identical. This avoids redundant work and can significantly improve performance."}
{"Instruction":"Assess maintainability of conditional logic.","question":"A large if-else chain handles many different cases. What alternative designs exist?","think":"Consider polymorphism or strategy patterns.","answer":"Replace large conditional chains with polymorphism, strategy objects, or a lookup table. This improves extensibility and reduces the risk of errors when adding new cases."}
{"Instruction":"Review the code for adherence to clean code principles.","question":"Functions are several hundred lines long. What issues does this raise?","think":"Evaluate function responsibility and readability.","answer":"Long functions often hide multiple responsibilities. Break them into smaller, well-named functions that each do one thing clearly and predictably."}
{"Instruction":"Analyze the code for scalability concerns.","question":"The algorithm processes data sequentially even though tasks are independent. What can be improved?","think":"Identify opportunities for parallelism or concurrency.","answer":"Independent tasks can be parallelized to improve scalability. Introduce concurrency or asynchronous processing while ensuring thread safety and proper resource management."}
{"Instruction":"Evaluate data structure choices.","question":"A list is frequently searched for membership checks. Is this optimal?","think":"Analyze time complexity implications.","answer":"For frequent membership checks, a set or hash-based structure provides better average time complexity than a list, improving performance for large datasets."}
{"Instruction":"Review the code for clarity of intent.","question":"Complex logic is implemented without comments or documentation. Why is this risky?","think":"Assess long-term maintainability.","answer":"Lack of documentation makes intent unclear to future maintainers. Add comments explaining why the logic exists, not just what it does, and document assumptions and constraints."}
{"Instruction":"Analyze the API design.","question":"Public methods expose internal data structures directly. What is the risk?","think":"Consider encapsulation and coupling.","answer":"Exposing internal structures couples clients to implementation details. Return abstractions or copies to preserve encapsulation and allow internal changes without breaking consumers."}
{"Instruction":"Review the code for robustness.","question":"Input validation is missing for external data. What problems may occur?","think":"Identify security and stability risks.","answer":"Missing validation can lead to crashes, undefined behavior, or security vulnerabilities. Validate inputs early and fail fast with clear error messages."}
{"Instruction":"Evaluate logging practices in the code.","question":"Logs lack context such as identifiers or state information. Why is this insufficient?","think":"Assess observability and debugging effectiveness.","answer":"Logs without context are hard to correlate and debug. Include relevant identifiers, state, and error details to improve traceability in production environments."}
{"Instruction":"Analyze the code for future extensibility.","question":"Adding a new feature requires modifying many existing files. What does this indicate?","think":"Check for tight coupling and design rigidity.","answer":"This suggests tight coupling and poor modularity. Refactor toward loosely coupled components with clear interfaces to make extensions localized and safer."}
{"Instruction":"Review the code from a refactoring standpoint.","question":"Temporary hacks were added to meet deadlines and never removed. What should be done?","think":"Evaluate technical debt management.","answer":"Identify and track technical debt explicitly. Schedule refactoring to remove hacks, add tests, and restore code quality before the debt compounds further."}
{"Instruction":"Assess consistency in the codebase.","question":"Different modules follow different coding styles and conventions. Why is this a problem?","think":"Consider team collaboration and readability.","answer":"Inconsistent styles increase friction and cognitive overhead. Adopt and enforce shared coding standards through guidelines, linters, and code reviews."}
{"Instruction":"Review algorithmic efficiency.","question":"An O(n^2) algorithm is used where n can grow large. What should be considered?","think":"Analyze algorithmic complexity and alternatives.","answer":"Evaluate more efficient algorithms or data structures to reduce time complexity. Profiling and complexity analysis should guide optimization decisions."}
{"Instruction":"Analyze the code for boundary management.","question":"Business rules depend on framework-specific APIs. Why is this risky?","think":"Check coupling between domain and infrastructure.","answer":"Tight coupling to frameworks makes changes costly. Isolate business rules in a domain layer and interact with frameworks through adapters or interfaces."}
{"Instruction":"Review the code for defensive programming.","question":"The code assumes external services always respond correctly. What could go wrong?","think":"Identify resilience and failure scenarios.","answer":"External services can fail or return invalid data. Add timeouts, retries, validation, and graceful degradation to improve system resilience."}
{"Instruction":"Review the code for long-term maintainability.","question":"Configuration values are hard-coded throughout the codebase. What issues does this create?","think":"Identify maintainability and deployment risks.","answer":"Hard-coded configuration makes changes error-prone and environment-specific. Centralize configuration, externalize environment-dependent values, and provide defaults with validation."}
{"Instruction":"Analyze the code for abstraction quality.","question":"Low-level utility functions are directly called from high-level business logic. Why is this problematic?","think":"Evaluate dependency direction and layering.","answer":"This creates tight coupling and violates dependency inversion. High-level modules should depend on abstractions, not concrete low-level utilities."}
{"Instruction":"Review the code for performance bottlenecks.","question":"A large object is repeatedly serialized and deserialized across layers. What can be improved?","think":"Look for unnecessary data transformations.","answer":"Avoid redundant serialization by passing structured data across layers or introducing well-defined data transfer objects. Reduce transformation boundaries where possible."}
{"Instruction":"Assess code clarity and intent.","question":"Magic numbers appear in multiple calculations without explanation. What should be done?","think":"Identify readability and maintainability concerns.","answer":"Replace magic numbers with named constants or configuration values that explain their purpose and domain meaning."}
{"Instruction":"Evaluate the design for extensibility.","question":"Adding a new rule requires modifying an existing switch statement. What does this indicate?","think":"Check for Open/Closed Principle violations.","answer":"The design violates the Open/Closed Principle. Introduce extensible mechanisms such as strategies, plugins, or rule registries to allow new behavior without modifying existing code."}
{"Instruction":"Review the code for test isolation.","question":"Unit tests require a real database to run. Why is this undesirable?","think":"Analyze test speed and reliability.","answer":"Tests dependent on real databases are slow and fragile. Replace them with mocks or in-memory substitutes to keep unit tests fast and deterministic."}
{"Instruction":"Analyze resource management.","question":"Files and network connections are opened but not explicitly closed. What risks does this pose?","think":"Consider resource leaks and system stability.","answer":"Unreleased resources can cause memory leaks and exhaustion. Ensure deterministic cleanup using scoped lifetimes or explicit close mechanisms."}
{"Instruction":"Evaluate code robustness.","question":"The code assumes input collections are never empty. What could go wrong?","think":"Identify edge cases and failure modes.","answer":"Empty inputs may cause runtime errors or incorrect results. Validate assumptions and handle edge cases explicitly."}
{"Instruction":"Review concurrency safety.","question":"Shared mutable state is accessed by multiple threads without synchronization. What is the concern?","think":"Analyze race conditions and data integrity.","answer":"Unsynchronized access can cause race conditions and corrupted state. Use immutability, proper synchronization, or concurrency-safe structures."}
{"Instruction":"Assess logging and monitoring strategy.","question":"The system logs every operation at the same severity level. Why is this ineffective?","think":"Evaluate operational observability.","answer":"Uniform log levels reduce signal-to-noise ratio. Use appropriate severity levels to distinguish normal behavior from warnings and errors."}
{"Instruction":"Analyze the code for coupling.","question":"Changing a data model requires widespread changes across the codebase. What does this reveal?","think":"Identify structural dependencies.","answer":"This indicates tight coupling to the data model. Introduce boundaries such as DTOs or mapping layers to isolate changes."}
{"Instruction":"Review API usage patterns.","question":"Public methods return null to indicate failure. What alternative approaches exist?","think":"Consider error signaling strategies.","answer":"Returning null hides failure causes and invites errors. Use explicit error objects, result types, or exceptions to make failure states clear."}
{"Instruction":"Evaluate the code for readability.","question":"Nested loops and conditionals make the logic hard to follow. How can this be improved?","think":"Look for simplification techniques.","answer":"Flatten nested logic using early returns, guard clauses, or extracted helper functions to improve readability."}
{"Instruction":"Analyze the system for scalability limits.","question":"All requests are processed synchronously even when results are not immediately required. What could be improved?","think":"Consider asynchronous processing opportunities.","answer":"Introduce asynchronous or background processing to improve throughput and responsiveness for non-blocking tasks."}
{"Instruction":"Review code reuse practices.","question":"Similar logic is reimplemented in different services. Why is this risky?","think":"Identify maintenance and consistency issues.","answer":"Duplicated logic increases the chance of inconsistent behavior. Centralize shared logic in reusable modules or libraries."}
{"Instruction":"Assess boundary validation.","question":"Internal assumptions are exposed to external callers. What is the risk?","think":"Check contract clarity and defensive design.","answer":"Exposed assumptions can be violated by callers. Define explicit contracts and validate inputs at boundaries."}
{"Instruction":"Analyze code evolution risks.","question":"Deprecated functions remain widely used. What should be done?","think":"Evaluate technical debt lifecycle.","answer":"Provide clear deprecation paths, warnings, and migration guides. Gradually remove deprecated functions to keep the codebase healthy."}
{"Instruction":"Review the code for predictability.","question":"Functions have side effects that are not documented. Why is this problematic?","think":"Assess reasoning and debugging complexity.","answer":"Hidden side effects make behavior unpredictable. Document side effects clearly or refactor toward pure functions."}
{"Instruction":"Evaluate defensive coding practices.","question":"The code trusts external API responses without validation. What should be improved?","think":"Identify reliability and security concerns.","answer":"Validate external responses for structure and constraints before use to prevent cascading failures or vulnerabilities."}
{"Instruction":"Analyze maintainability of shared libraries.","question":"A common utility module changes frequently and breaks multiple consumers. What is the issue?","think":"Assess stability and contract management.","answer":"Shared libraries should have stable contracts. Introduce versioning, backward compatibility, and clear ownership to reduce breakage."}
{"Instruction":"Review code complexity.","question":"Cyclomatic complexity is very high in critical functions. Why does this matter?","think":"Evaluate testing and correctness risks.","answer":"High complexity increases bug risk and testing difficulty. Simplify logic, split functions, and reduce branching paths."}
{"Instruction":"Assess configuration management.","question":"Feature flags are implemented with scattered conditionals. What is a better approach?","think":"Look for centralized control mechanisms.","answer":"Centralize feature flag evaluation to avoid scattered conditional logic and ensure consistent behavior across the system."}
{"Instruction":"Analyze the code for correctness guarantees.","question":"Assertions are used to enforce business rules in production code. What is the risk?","think":"Consider runtime behavior and safety.","answer":"Assertions may be disabled in production, removing critical checks. Use explicit validations and error handling for business rules."}
{"Instruction":"Review the code for domain modeling quality.","question":"Primitive types are used to represent important domain concepts. What could be improved?","think":"Identify domain expressiveness issues.","answer":"Introduce domain-specific types or value objects to encode rules and improve correctness and readability."}
{"Instruction":"Evaluate the impact of premature optimization.","question":"Complex optimizations were added without evidence of bottlenecks. Why is this risky?","think":"Assess cost-benefit of optimization.","answer":"Premature optimization increases complexity without clear benefit. Use profiling to guide optimizations based on real bottlenecks."}
{"Instruction":"Analyze the algorithmic complexity of the code.","question":"A function iterates over two nested loops where both depend on input size n. What is the concern?","think":"Identify time complexity and scalability impact.","answer":"The time complexity is O(n^2), which may not scale for large n. Evaluate whether the nested iteration is necessary or if data structures or algorithms can reduce complexity."}
{"Instruction":"Review the code for unnecessary memory usage.","question":"Large temporary data structures are created inside a frequently called function. What should be improved?","think":"Analyze memory allocation patterns.","answer":"Repeated allocation increases memory pressure and GC overhead. Reuse data structures, reduce scope, or stream data instead of materializing large intermediates."}
{"Instruction":"Evaluate the trade-offs between time and space complexity.","question":"An optimization caches all computed results in memory. What risk does this introduce?","think":"Consider memory growth and eviction.","answer":"Unbounded caching can cause memory exhaustion. Introduce size limits, eviction policies, or selective caching based on access patterns."}
{"Instruction":"Analyze the performance characteristics of a search operation.","question":"A linear scan is used repeatedly to find elements by key. What alternative should be considered?","think":"Assess data structure efficiency.","answer":"Replace linear scans with hash-based or indexed structures to reduce average lookup time from O(n) to O(1) or O(log n)."}
{"Instruction":"Review the algorithm for worst-case behavior.","question":"The algorithm performs well on average but degrades significantly for certain inputs. Why is this risky?","think":"Identify worst-case complexity implications.","answer":"Poor worst-case behavior can cause latency spikes or denial-of-service scenarios. Prefer algorithms with stable or bounded worst-case guarantees."}
{"Instruction":"Analyze memory locality and cache behavior.","question":"The code frequently accesses large arrays with non-sequential patterns. What is the impact?","think":"Consider CPU cache efficiency.","answer":"Non-sequential access causes cache misses and reduces performance. Reorder data access to improve spatial locality and cache utilization."}
{"Instruction":"Evaluate recursion usage.","question":"A recursive function has depth proportional to input size. What should be considered?","think":"Assess stack memory usage.","answer":"Deep recursion risks stack overflow. Consider iterative implementations or explicit stacks when recursion depth is unbounded."}
{"Instruction":"Review the performance impact of object creation.","question":"Objects are created in tight loops for short-lived use. Why is this inefficient?","think":"Analyze allocation and garbage collection costs.","answer":"Frequent object allocation increases GC pressure. Use object pooling, reuse instances, or prefer value types when appropriate."}
{"Instruction":"Analyze concurrent performance.","question":"A global lock protects a frequently accessed data structure. What is the bottleneck?","think":"Identify contention issues.","answer":"A coarse-grained lock limits parallelism and scalability. Use finer-grained locking, lock-free structures, or partitioned data."}
{"Instruction":"Review memory ownership and lifetime.","question":"Multiple components share mutable data without clear ownership. What risks arise?","think":"Assess memory safety and correctness.","answer":"Unclear ownership can cause data races, leaks, or unintended mutations. Define ownership boundaries and prefer immutable data sharing."}
{"Instruction":"Evaluate algorithm choice.","question":"Sorting is performed repeatedly on mostly sorted data. What optimization is possible?","think":"Analyze input characteristics.","answer":"Use algorithms optimized for nearly sorted data or maintain sorted order incrementally to reduce average sorting cost."}
{"Instruction":"Analyze I/O performance.","question":"Small writes are issued individually to storage or network. Why is this inefficient?","think":"Consider syscall and buffering overhead.","answer":"Frequent small I/O operations increase overhead. Batch writes or use buffering to amortize I/O costs."}
{"Instruction":"Review space complexity.","question":"The algorithm creates a copy of the entire input data for processing. What is the impact?","think":"Evaluate memory duplication.","answer":"Full data copies double memory usage and reduce scalability. Prefer in-place processing or streaming approaches when possible."}
{"Instruction":"Analyze lazy vs eager evaluation.","question":"All data is loaded into memory before processing begins. What alternative exists?","think":"Assess memory and latency trade-offs.","answer":"Lazy or streaming processing reduces peak memory usage and improves time-to-first-result for large datasets."}
{"Instruction":"Evaluate branch predictability.","question":"Hot code paths contain complex conditional logic. How does this affect performance?","think":"Consider CPU branch prediction.","answer":"Unpredictable branches reduce CPU pipeline efficiency. Simplify conditions or restructure logic to favor predictable branches."}
{"Instruction":"Review algorithmic assumptions.","question":"The code assumes input size will remain small. Why is this dangerous?","think":"Assess future scalability risks.","answer":"Assumptions about small input sizes often break over time. Design with scalability in mind and document constraints explicitly."}
{"Instruction":"Analyze the cost of abstraction.","question":"Multiple abstraction layers are used in a performance-critical path. What should be evaluated?","think":"Consider overhead vs. maintainability.","answer":"Excessive abstraction can add call overhead and indirection. Measure performance and flatten layers selectively in hot paths."}
{"Instruction":"Evaluate data representation.","question":"Data is stored in a format optimized for readability rather than access speed. What is the trade-off?","think":"Assess performance vs. clarity.","answer":"Readable formats may increase parsing and access costs. Consider alternative representations internally while preserving clear external interfaces."}
{"Instruction":"Review memory fragmentation risks.","question":"Long-lived and short-lived objects are allocated together. Why is this problematic?","think":"Analyze heap behavior.","answer":"Mixed lifetimes increase fragmentation and GC cost. Separate allocation strategies or memory pools by object lifetime."}
{"Instruction":"Analyze parallel workload distribution.","question":"Work is evenly split by input size but tasks vary greatly in execution time. What is the issue?","think":"Identify load imbalance.","answer":"Uneven task cost causes poor parallel efficiency. Use dynamic scheduling or work stealing to balance load."}
{"Instruction":"Evaluate algorithm stability.","question":"Performance varies widely between runs with similar inputs. What might cause this?","think":"Assess non-deterministic factors.","answer":"Cache effects, GC timing, or contention can cause variability. Profile under controlled conditions to identify sources of instability."}
{"Instruction":"Review memory access patterns.","question":"Pointer-heavy data structures are used in performance-critical sections. What is the downside?","think":"Consider cache friendliness.","answer":"Pointer chasing reduces cache efficiency. Favor contiguous data layouts to improve memory access speed."}
{"Instruction":"Analyze time complexity under composition.","question":"Multiple O(n) operations are chained together. Why might this still be problematic?","think":"Consider constant factors and passes.","answer":"Although asymptotically linear, multiple passes increase constants. Combine operations where possible to reduce total work."}
{"Instruction":"Evaluate performance measurement practices.","question":"Optimization decisions are made without profiling data. What is the risk?","think":"Assess evidence-based optimization.","answer":"Without profiling, optimizations may target non-critical paths. Use measurements to guide effective performance improvements."}
{"Instruction":"Review algorithm termination conditions.","question":"A loop depends on floating-point convergence. What should be considered?","think":"Assess termination guarantees.","answer":"Floating-point errors may prevent convergence. Add iteration limits and tolerance thresholds to ensure termination."}
{"Instruction":"Analyze CPU cache utilization in the code.","question":"Multiple threads update different fields of the same object concurrently. What low-level issue can occur?","think":"Identify cache line behavior and false sharing.","answer":"Even if fields are logically independent, they may share a cache line, causing false sharing. This leads to excessive cache invalidation and degraded performance. Padding or reorganizing data can mitigate this."}
{"Instruction":"Review memory access patterns for cache efficiency.","question":"A loop traverses a 2D array column by column instead of row by row. Why is this slow?","think":"Consider spatial locality and cache lines.","answer":"Column-wise access breaks spatial locality, causing frequent cache misses. Iterating in memory layout order improves cache utilization and performance."}
{"Instruction":"Evaluate NUMA awareness.","question":"Threads frequently access memory allocated on a remote NUMA node. What is the impact?","think":"Analyze memory locality across NUMA nodes.","answer":"Remote memory access has higher latency and lower bandwidth. Allocate memory close to the threads that use it and minimize cross-node access."}
{"Instruction":"Analyze garbage collection pressure.","question":"Large numbers of short-lived objects are allocated in hot paths. What happens at runtime?","think":"Consider GC allocation and collection behavior.","answer":"Frequent short-lived allocations increase GC frequency and pause time. Reducing allocations or reusing objects can significantly improve throughput."}
{"Instruction":"Review allocator behavior.","question":"The application frequently allocates and frees small objects of varying sizes. What is the concern?","think":"Identify allocator fragmentation risks.","answer":"Mixed-size allocations can fragment memory and slow allocation. Use size-class allocators or pools to reduce fragmentation and improve predictability."}
{"Instruction":"Analyze write-heavy workloads.","question":"Multiple cores repeatedly write to the same shared counter. Why does this not scale?","think":"Consider cache coherence protocols.","answer":"Writes invalidate cache lines across cores, causing coherence traffic. Use per-thread counters with aggregation to reduce contention."}
{"Instruction":"Review memory alignment.","question":"Data structures are not aligned to cache line boundaries. What could be affected?","think":"Assess alignment and access efficiency.","answer":"Misaligned data can cause extra memory accesses or split cache-line reads. Align hot data to cache line boundaries for better performance."}
{"Instruction":"Analyze GC tuning implications.","question":"A low-latency system experiences occasional long pauses. What GC-related factor might be responsible?","think":"Identify stop-the-world GC behavior.","answer":"Full or major garbage collection cycles can cause stop-the-world pauses. Adjust heap sizing, generations, or switch to a low-pause collector."}
{"Instruction":"Evaluate memory bandwidth saturation.","question":"Adding more threads no longer increases throughput. What hardware limit might be reached?","think":"Consider shared resource bottlenecks.","answer":"The workload may be memory-bandwidth bound. Beyond a point, additional threads increase contention without improving performance."}
{"Instruction":"Review allocator contention.","question":"All threads allocate memory from a single global heap. What happens under load?","think":"Analyze lock contention in allocators.","answer":"A shared allocator can become a scalability bottleneck. Use thread-local or per-core allocators to reduce contention."}
{"Instruction":"Analyze read-mostly data access.","question":"Frequently read configuration data is protected by a mutex. What is inefficient here?","think":"Assess synchronization overhead.","answer":"Locking adds overhead for read-heavy access. Use immutable snapshots or lock-free read mechanisms for read-mostly data."}
{"Instruction":"Evaluate pointer chasing costs.","question":"Linked lists are heavily used in performance-critical paths. Why might this be slow?","think":"Consider cache miss behavior.","answer":"Pointer chasing causes poor cache locality and frequent cache misses. Contiguous data structures often perform better on modern CPUs."}
{"Instruction":"Review NUMA-unaware allocation.","question":"Memory is allocated during initialization on a single thread, then used by many worker threads. What is the issue?","think":"Identify first-touch NUMA effects.","answer":"First-touch allocation binds memory to one NUMA node, causing remote access for other threads. Allocate memory in parallel or on the owning threads."}
{"Instruction":"Analyze false sharing risks.","question":"An array of per-thread statistics is stored contiguously. What could go wrong?","think":"Assess cache line sharing.","answer":"Adjacent elements may share cache lines, causing false sharing. Add padding between per-thread entries to isolate cache lines."}
{"Instruction":"Evaluate GC root management.","question":"Long-lived references keep large object graphs reachable. What is the impact?","think":"Consider object lifetime and GC reachability.","answer":"Retained references prevent garbage collection, increasing memory usage and GC cost. Shorten object lifetimes and clear references promptly."}
{"Instruction":"Review instruction-level efficiency.","question":"Hot loops contain complex function calls. What CPU-level cost is incurred?","think":"Consider inlining and pipeline effects.","answer":"Function call overhead and reduced inlining can hurt instruction cache and pipeline efficiency. Simplify hot loops or enable inlining."}
{"Instruction":"Analyze allocator lifetime mismatch.","question":"Objects with very different lifetimes are allocated from the same pool. Why is this problematic?","think":"Assess fragmentation and reuse.","answer":"Long-lived objects block reuse of freed memory from short-lived ones. Separate allocation pools by expected lifetime."}
{"Instruction":"Evaluate atomic operation usage.","question":"Atomic operations are used heavily even when contention is low. What is the cost?","think":"Consider memory ordering and fences.","answer":"Atomics impose memory ordering constraints and fences, which are costly. Use non-atomic operations when synchronization is unnecessary."}
{"Instruction":"Review cache invalidation patterns.","question":"Frequently updated shared flags are read by many threads. Why does this hurt performance?","think":"Analyze coherence traffic.","answer":"Each update invalidates cache lines across cores, creating coherence storms. Use local copies or event-based signaling."}
{"Instruction":"Analyze heap sizing strategy.","question":"The heap is sized too small for peak workload. What GC behavior results?","think":"Consider allocation rate vs collection rate.","answer":"Small heaps trigger frequent garbage collections, increasing overhead. Proper heap sizing reduces GC frequency and improves throughput."}
{"Instruction":"Evaluate memory prefetching.","question":"The access pattern is predictable but performance is still poor. What low-level technique could help?","think":"Consider hardware prefetch behavior.","answer":"Explicit or implicit prefetching can help hide memory latency when access patterns are predictable."}
{"Instruction":"Review lock granularity.","question":"A single lock protects a large data structure with independent regions. What is suboptimal?","think":"Assess contention and scalability.","answer":"Coarse-grained locking limits parallelism. Split the structure or lock by region to reduce contention."}
{"Instruction":"Analyze cache hierarchy effects.","question":"Performance differs significantly between L1, L2, and L3 cache residency. Why does this matter?","think":"Consider memory latency hierarchy.","answer":"Each cache level has different latency. Keeping hot data in lower-level caches dramatically improves performance."}
{"Instruction":"Evaluate memory allocator choice.","question":"The default allocator performs poorly under high concurrency. What should be considered?","think":"Assess allocator design trade-offs.","answer":"Different allocators optimize for different workloads. Choose allocators designed for concurrency, locality, or low fragmentation based on workload needs."}
{"Instruction":"Analyze NUMA effects in containerized environments.","question":"A container shows high memory latency despite low CPU usage on a multi-socket machine. What might be happening?","think":"Consider NUMA memory locality and container scheduling.","answer":"The container may be running on one NUMA node while accessing memory allocated on another. NUMA-unaware scheduling and memory allocation can cause remote memory access and increased latency."}
{"Instruction":"Review performance implications of virtual machines.","question":"A workload runs significantly slower inside a VM compared to bare metal. What low-level factors should be examined?","think":"Identify virtualization overhead sources.","answer":"Examine virtualized CPU scheduling, memory translation overhead, NUMA alignment, and I/O virtualization layers that add latency compared to bare metal."}
{"Instruction":"Evaluate container CPU pinning.","question":"A latency-sensitive service runs in containers without CPU affinity settings. What is the risk?","think":"Assess scheduler-induced cache effects.","answer":"Without CPU pinning, threads may migrate across cores, causing cache invalidation and NUMA remote access. Pinning CPUs improves cache locality and predictable latency."}
{"Instruction":"Analyze memory allocation in cloud environments.","question":"Memory usage appears balanced, but performance degrades under load in a multi-tenant cloud. Why?","think":"Consider noisy neighbor and shared resource contention.","answer":"Other tenants may saturate memory bandwidth or caches, causing contention. Cloud environments share hardware resources, impacting performance despite apparent capacity."}
{"Instruction":"Review cgroup memory limits.","question":"A container hits performance cliffs before reaching its memory limit. What is a possible explanation?","think":"Consider page reclaim and cgroup behavior.","answer":"The kernel may reclaim pages aggressively within the cgroup, causing frequent page faults and cache eviction even before hitting hard limits."}
{"Instruction":"Evaluate NUMA awareness in VM placement.","question":"A VM is assigned vCPUs across multiple NUMA nodes. What problem can this cause?","think":"Analyze CPU-memory distance effects.","answer":"Cross-NUMA vCPU placement increases memory access latency and reduces cache locality. Align vCPUs and memory within the same NUMA node when possible."}
{"Instruction":"Analyze container startup allocation behavior.","question":"Containers allocate most memory at startup on a single thread. Why might this hurt later performance?","think":"Apply first-touch NUMA policy.","answer":"First-touch allocation binds memory to the NUMA node of the startup thread, causing remote access for other threads. Parallel allocation improves locality."}
{"Instruction":"Review hypervisor scheduling effects.","question":"Latency spikes occur at regular intervals inside VMs. What could be causing this?","think":"Consider hypervisor-level scheduling and pauses.","answer":"Hypervisor scheduling, VM descheduling, or host-level maintenance tasks can preempt the VM, causing periodic latency spikes."}
{"Instruction":"Evaluate memory overcommitment.","question":"Cloud instances perform well initially but degrade over time. What memory-related factor might be involved?","think":"Consider ballooning and swapping.","answer":"Memory overcommitment can trigger ballooning or swapping at the hypervisor level, dramatically increasing memory access latency."}
{"Instruction":"Analyze container I/O performance.","question":"Disk I/O latency is inconsistent across identical containers. Why?","think":"Assess shared storage contention.","answer":"Containers often share underlying storage. I/O contention from other workloads can cause unpredictable latency despite identical container configurations."}
{"Instruction":"Review NUMA tuning in orchestration platforms.","question":"Kubernetes schedules pods without NUMA awareness by default. What impact can this have?","think":"Consider scheduler limitations.","answer":"NUMA-unaware scheduling may place pods suboptimally, increasing remote memory access and cache misses. NUMA-aware scheduling improves performance for sensitive workloads."}
{"Instruction":"Analyze CPU throttling effects.","question":"A container experiences sudden throughput drops under sustained load. What cgroup behavior might explain this?","think":"Assess CPU quota enforcement.","answer":"CPU cgroup throttling can limit execution once quotas are exceeded, causing periodic stalls and reduced throughput."}
{"Instruction":"Evaluate VM NUMA configuration.","question":"A large VM is configured without exposing NUMA topology to the guest OS. Why is this an issue?","think":"Consider guest OS scheduling decisions.","answer":"Without NUMA topology awareness, the guest OS cannot optimize memory placement or scheduling, leading to inefficient remote memory access."}
{"Instruction":"Review cloud instance heterogeneity.","question":"Identical instance types show different performance characteristics. Why might this occur?","think":"Consider underlying hardware variation.","answer":"Cloud providers may use different CPU generations or memory configurations under the same instance type, leading to performance variability."}
{"Instruction":"Analyze container memory fragmentation.","question":"A long-running container shows increasing memory latency over time. What could be happening?","think":"Consider allocator and page layout.","answer":"Fragmentation within the container’s memory cgroup can reduce locality and increase TLB and cache misses."}
{"Instruction":"Evaluate noisy neighbor mitigation.","question":"Performance degrades during peak hours in a shared cluster. What strategies help?","think":"Assess isolation mechanisms.","answer":"Use resource requests, limits, CPU pinning, and dedicated nodes to isolate workloads from noisy neighbors."}
{"Instruction":"Review VM I/O virtualization.","question":"Network latency inside a VM is higher than expected. What virtualization layer should be examined?","think":"Analyze network stack layering.","answer":"Virtual NIC drivers, software switches, and hypervisor networking layers can add latency compared to direct hardware access."}
{"Instruction":"Analyze NUMA-aware scaling.","question":"Scaling a service to more cores yields diminishing returns on a multi-socket machine. Why?","think":"Consider cross-socket contention.","answer":"Cross-NUMA communication and memory access reduce scaling efficiency. NUMA-aware sharding improves scalability."}
{"Instruction":"Evaluate container eviction behavior.","question":"Pods are evicted even though node-level resources appear sufficient. What is happening?","think":"Consider cgroup and QoS classes.","answer":"Local cgroup pressure or QoS prioritization can trigger evictions even when aggregate resources look available."}
{"Instruction":"Review cloud auto-scaling latency.","question":"Auto-scaled instances take too long to handle traffic spikes. What performance factor is overlooked?","think":"Assess cold-start and initialization costs.","answer":"Cold-start costs include VM boot, container startup, memory allocation, and cache warm-up, which delay effective capacity."}
{"Instruction":"Analyze NUMA and garbage collection interaction.","question":"GC pause times increase on multi-socket machines. Why might NUMA matter?","think":"Consider memory locality during GC.","answer":"GC may traverse memory across NUMA nodes, increasing latency. NUMA-aware allocation and GC tuning can reduce pause times."}
{"Instruction":"Evaluate scheduling fairness.","question":"One container starves others despite limits being set. What might be wrong?","think":"Assess scheduler and limit enforcement.","answer":"Misconfigured limits or burstable workloads can monopolize shared resources, causing starvation despite nominal limits."}
{"Instruction":"Review VM CPU overcommitment.","question":"vCPU usage looks low but performance is inconsistent. Why?","think":"Consider host-level contention.","answer":"CPU overcommitment allows many vCPUs to share fewer physical cores, leading to unpredictable scheduling and latency."}
{"Instruction":"Analyze NUMA behavior in cloud databases.","question":"A stateful service shows uneven latency across replicas on the same instance type. Why?","think":"Consider memory placement differences.","answer":"Different replicas may have memory allocated on different NUMA nodes, causing inconsistent access latency."}
{"Instruction":"Evaluate container placement strategy.","question":"Performance improves when pods are co-located rather than spread out. Why?","think":"Assess locality benefits.","answer":"Co-location can improve cache and NUMA locality, reducing cross-node communication for tightly coupled workloads."}
{"Instruction":"Analyze performance behavior in a cloud environment.","question":"A latency-sensitive service slows down after scaling to more cores on a multi-socket VM. Why?","think":"Scaling adds cross-socket traffic. Threads migrate, cache locality drops, and memory access becomes remote due to NUMA effects.","answer":"NUMA penalties dominate. More cores increase remote memory access and cache invalidation."}
{"Instruction":"Review container CPU scheduling impact.","question":"A container shows inconsistent latency despite low CPU usage. What is likely happening?","think":"The scheduler migrates threads across cores, invalidating caches and increasing memory latency.","answer":"Lack of CPU pinning causes cache thrash and unpredictable latency."}
{"Instruction":"Analyze GC behavior on large cloud instances.","question":"GC pause times increase after moving to larger VM sizes. Why?","think":"Larger heaps span NUMA nodes, forcing GC to traverse remote memory.","answer":"GC becomes NUMA-unfriendly, increasing pause latency."}
{"Instruction":"Evaluate allocator performance under concurrency.","question":"Throughput drops when many threads allocate small objects concurrently. Why?","think":"Allocator locks and cache-line contention dominate under high concurrency.","answer":"Allocator contention becomes the bottleneck."}
{"Instruction":"Analyze NUMA behavior in container startup.","question":"Containers perform well initially but degrade under load. What is the root cause?","think":"Memory is first-touched by a single startup thread, binding pages to one NUMA node.","answer":"First-touch NUMA misplacement causes remote memory access."}
{"Instruction":"Review VM scheduling effects.","question":"Latency spikes appear periodically inside a VM. What should be suspected?","think":"The VM is being descheduled or preempted by the hypervisor.","answer":"Hypervisor scheduling interruptions cause the spikes."}
{"Instruction":"Analyze memory bandwidth scaling.","question":"Adding threads no longer improves throughput on a cloud instance. Why?","think":"The workload saturates memory bandwidth rather than CPU.","answer":"The system is memory-bandwidth bound."}
{"Instruction":"Evaluate false sharing risk.","question":"Per-thread counters are stored in an array. Performance drops as threads increase. Why?","think":"Counters share cache lines, causing frequent invalidation.","answer":"False sharing kills scalability."}
{"Instruction":"Review container memory limits.","question":"A container slows down before hitting its memory limit. Why?","think":"The kernel reclaims pages aggressively within the cgroup.","answer":"Early page reclaim degrades cache locality."}
{"Instruction":"Analyze NUMA-unaware VM configuration.","question":"A VM spans multiple sockets but shows poor scaling. Why?","think":"vCPUs and memory are placed across NUMA nodes without alignment.","answer":"Cross-NUMA placement increases latency."}
{"Instruction":"Evaluate pointer-heavy data structures.","question":"Linked structures underperform in a hot path. Why?","think":"Pointer chasing causes cache misses and poor prefetching.","answer":"Cache locality is too poor."}
{"Instruction":"Review container noisy neighbor effects.","question":"Performance drops during peak cluster usage. Why?","think":"Other workloads compete for shared caches and memory bandwidth.","answer":"Noisy neighbors steal shared hardware resources."}
{"Instruction":"Analyze cloud instance variability.","question":"Same instance type shows different performance across deployments. Why?","think":"Underlying hardware differs despite identical instance labels.","answer":"Cloud hardware heterogeneity causes variance."}
{"Instruction":"Evaluate atomic operation overhead.","question":"Replacing atomics with plain writes improves performance. Why?","think":"Atomics introduce fences and coherence traffic.","answer":"Atomic memory ordering was unnecessary overhead."}
{"Instruction":"Review GC allocation patterns.","question":"High allocation rates reduce throughput even with fast CPUs. Why?","think":"GC work scales with allocation rate, not CPU speed.","answer":"Allocation pressure dominates runtime cost."}
{"Instruction":"Analyze NUMA-aware sharding.","question":"Sharding data by socket improves performance. Why?","think":"Sharding aligns computation and memory within NUMA nodes.","answer":"Locality reduces remote memory access."}
{"Instruction":"Evaluate container eviction behavior.","question":"Pods are evicted despite sufficient node memory. Why?","think":"Local cgroup pressure triggers eviction before node exhaustion.","answer":"Cgroup-level pressure causes eviction."}
{"Instruction":"Review memory fragmentation over time.","question":"A long-running service gets slower without higher load. Why?","think":"Allocator fragmentation degrades locality and increases TLB misses.","answer":"Fragmentation erodes memory efficiency."}
{"Instruction":"Analyze I/O virtualization overhead.","question":"Network latency inside a VM is higher than expected. Why?","think":"Packets traverse virtual NICs and software switches.","answer":"Virtualized I/O adds extra hops."}
{"Instruction":"Evaluate CPU throttling effects.","question":"Throughput drops periodically under sustained load. Why?","think":"CPU quotas trigger throttling when limits are exceeded.","answer":"Cgroup CPU throttling stalls execution."}
{"Instruction":"Analyze NUMA impact on caches.","question":"Cross-socket access hurts even read-heavy workloads. Why?","think":"Remote cache lines increase latency despite no writes.","answer":"Cache access becomes remote and slower."}
{"Instruction":"Review cold-start performance.","question":"Auto-scaled instances fail to absorb traffic spikes quickly. Why?","think":"VM boot, container init, allocation, and cache warm-up take time.","answer":"Cold-start latency delays capacity."}
{"Instruction":"Evaluate lock contention in VMs.","question":"A global lock scales worse in VMs than bare metal. Why?","think":"vCPU scheduling amplifies lock convoy effects.","answer":"Virtual scheduling worsens lock contention."}
{"Instruction":"Analyze NUMA and GC interaction.","question":"GC throughput drops on multi-socket machines. Why?","think":"GC threads traverse memory across NUMA boundaries.","answer":"NUMA-unaware GC hurts throughput."}
{"Instruction":"Review scheduler fairness.","question":"One container dominates CPU despite limits. Why?","think":"Burstable workloads exploit scheduler fairness.","answer":"Limits allow unfair CPU bursts."}
{"Instruction":"Evaluate cache hierarchy sensitivity.","question":"Small data layout changes drastically affect performance. Why?","think":"Data shifts across cache-line or cache-level boundaries.","answer":"Cache residency changed."}
{"Instruction":"Analyze cloud overcommitment.","question":"Low CPU usage but high latency inside VM. Why?","think":"Host overcommitment causes vCPU wait time.","answer":"vCPU contention hides behind low usage metrics."}
{"Instruction":"Review the design for maintainability.","question":"A single module handles validation, business rules, and persistence. What is the core issue?","think":"Multiple responsibilities are coupled, making changes risky and testing difficult.","answer":"Violates single responsibility; split into clear layers."}
{"Instruction":"Analyze the architecture for long-term evolution.","question":"Adding a new feature requires modifying many unrelated files. Why is this a problem?","think":"High coupling indicates missing abstraction boundaries.","answer":"The system is tightly coupled and hard to evolve."}
{"Instruction":"Review code structure.","question":"Business logic directly depends on framework APIs. What design issue does this reveal?","think":"Core logic should not be coupled to infrastructure details.","answer":"Domain logic is improperly coupled to infrastructure."}
{"Instruction":"Evaluate extensibility.","question":"New behavior is added by editing large conditional blocks. What principle is violated?","think":"Modifying existing logic for new behavior increases regression risk.","answer":"Violates the Open/Closed Principle."}
{"Instruction":"Analyze module boundaries.","question":"Internal data structures are exposed through public APIs. Why is this risky?","think":"Exposing internals couples consumers to implementation details.","answer":"Encapsulation is broken."}
{"Instruction":"Review abstraction quality.","question":"Interfaces mirror concrete implementations exactly. What does this indicate?","think":"Interfaces add no abstraction or flexibility.","answer":"The abstraction is redundant."}
{"Instruction":"Evaluate testability.","question":"Unit tests require complex setup across many components. What does this suggest?","think":"Tight coupling prevents isolated testing.","answer":"The design is not test-friendly."}
{"Instruction":"Analyze responsibility distribution.","question":"A class keeps growing as features are added. Why does this happen?","think":"The class is acting as a catch-all for unrelated concerns.","answer":"It has become a god object."}
{"Instruction":"Review dependency direction.","question":"High-level policies depend on low-level utilities. What is the architectural flaw?","think":"Dependencies should point toward abstractions.","answer":"Dependency inversion is violated."}
{"Instruction":"Evaluate change impact.","question":"Small changes frequently introduce bugs in distant modules. Why?","think":"Implicit coupling causes hidden dependencies.","answer":"Changes propagate due to tight coupling."}
{"Instruction":"Analyze API design.","question":"Methods accept many primitive parameters with implicit relationships. What is the issue?","think":"The API fails to model domain concepts explicitly.","answer":"The interface lacks domain expressiveness."}
{"Instruction":"Review code readability.","question":"Understanding a function requires reading several other files. Why is this undesirable?","think":"High cognitive load slows comprehension and maintenance.","answer":"The code lacks locality of behavior."}
{"Instruction":"Evaluate reuse strategy.","question":"Similar logic is copy-pasted across services. What is the long-term cost?","think":"Duplication leads to divergence and inconsistent behavior.","answer":"Technical debt accumulates quickly."}
{"Instruction":"Analyze abstraction leakage.","question":"Callers must understand internal state transitions to use a component correctly. Why is this bad design?","think":"Good abstractions hide internal complexity.","answer":"The abstraction leaks internal details."}
{"Instruction":"Review error handling design.","question":"Error handling logic is scattered across the codebase. What problem does this create?","think":"Inconsistent handling increases bugs and confusion.","answer":"Error handling lacks a unified strategy."}
{"Instruction":"Evaluate consistency.","question":"Different modules follow different architectural patterns. Why does this hurt maintainability?","think":"Inconsistency increases cognitive overhead for developers.","answer":"The system lacks architectural coherence."}
{"Instruction":"Analyze ownership boundaries.","question":"Multiple teams frequently modify the same core modules. What does this suggest?","think":"Unclear ownership often signals poor modularization.","answer":"Module boundaries are misaligned with ownership."}
{"Instruction":"Review dependency management.","question":"Changing a low-level utility forces recompilation of many modules. Why?","think":"Excessive compile-time dependencies indicate tight coupling.","answer":"Dependencies are too broad."}
{"Instruction":"Evaluate code evolution.","question":"Deprecated APIs remain heavily used. What architectural weakness does this reveal?","think":"Lack of migration paths slows evolution.","answer":"The system resists change."}
{"Instruction":"Analyze naming and intent.","question":"Class and method names describe how rather than why. Why is this problematic?","think":"Names should convey intent and domain meaning.","answer":"Intent is obscured."}
{"Instruction":"Review layering discipline.","question":"Lower layers call into higher layers for convenience. Why is this dangerous?","think":"Layering constraints enforce architectural direction.","answer":"Layer boundaries are violated."}
{"Instruction":"Evaluate modularity.","question":"Modules cannot be understood or reused independently. What is missing?","think":"Well-designed modules have clear contracts.","answer":"Module contracts are unclear."}
{"Instruction":"Analyze refactoring difficulty.","question":"Refactoring requires touching many files for a small improvement. Why?","think":"Poor cohesion spreads logic across the system.","answer":"Cohesion is too low."}
{"Instruction":"Review configuration design.","question":"Behavior changes require code changes instead of configuration updates. What does this indicate?","think":"Hard-coded behavior limits flexibility.","answer":"Configuration is underutilized."}
{"Instruction":"Evaluate architectural resilience.","question":"Introducing a new dependency breaks existing features. Why is this fragile?","think":"Hidden assumptions exist between components.","answer":"The architecture is brittle."}
{"Instruction":"Analyze domain modeling.","question":"Business rules are scattered across unrelated modules. Why is this harmful?","think":"Domain logic should be centralized.","answer":"The domain model is fragmented."}
{"Instruction":"Review interface stability.","question":"Small internal changes frequently break public APIs. What is wrong?","think":"Public APIs should be stable and protected.","answer":"API boundaries are poorly defined."}
{"Instruction":"Evaluate onboarding difficulty.","question":"New developers struggle to understand system flow. What is the root cause?","think":"Complex implicit interactions hide system behavior.","answer":"The architecture is not self-explanatory."}
{"Instruction":"Identify design anti-patterns in the code.","question":"One central class contains most business logic and coordinates many unrelated components. What anti-pattern is present?","think":"A single class accumulates responsibilities and becomes a change hotspot.","answer":"This is a God Object."}
{"Instruction":"Review the domain model quality.","question":"Domain objects only store data while all business rules live in services. What is the issue?","think":"Behavior is separated from data, weakening the domain model.","answer":"This is an Anemic Domain Model."}
{"Instruction":"Analyze change impact across the system.","question":"Implementing a small feature requires editing many files across modules. What anti-pattern does this indicate?","think":"Changes are scattered instead of localized.","answer":"This is Shotgun Surgery."}
{"Instruction":"Review responsibility allocation.","question":"A class frequently accesses and manipulates the internal data of another class. What is the smell?","think":"The class is more interested in another class’s data than its own.","answer":"This is Feature Envy."}
{"Instruction":"Analyze coupling between components.","question":"Two modules frequently change together despite having separate responsibilities. What does this suggest?","think":"Hidden dependencies cause synchronized changes.","answer":"This indicates Tight Coupling."}
{"Instruction":"Evaluate controller design.","question":"A controller handles validation, business logic, and persistence directly. What anti-pattern emerges?","think":"Multiple layers collapse into one component.","answer":"Controller has become a God Object."}
{"Instruction":"Review service growth over time.","question":"A service keeps accumulating methods unrelated to its original purpose. Why is this concerning?","think":"The service lacks a clear responsibility boundary.","answer":"It is evolving into a God Object."}
{"Instruction":"Analyze domain expressiveness.","question":"Business rules are implemented as utility functions operating on plain data structures. What is lost?","think":"The domain loses cohesion and meaning.","answer":"This reflects an Anemic Domain Model."}
{"Instruction":"Review modification patterns.","question":"Bug fixes require synchronized changes in multiple layers. What anti-pattern is visible?","think":"Lack of proper abstraction causes ripple effects.","answer":"This is Shotgun Surgery."}
{"Instruction":"Evaluate encapsulation.","question":"Getters expose internal state and callers perform complex logic on that data. What is the smell?","think":"Logic lives outside the owning object.","answer":"Feature Envy is present."}
{"Instruction":"Analyze architectural boundaries.","question":"Infrastructure concerns leak into domain objects. What anti-pattern does this reinforce?","think":"Domain purity is compromised by external concerns.","answer":"This contributes to an Anemic Domain Model."}
{"Instruction":"Review cohesion of a module.","question":"A module has many reasons to change for unrelated features. What does this indicate?","think":"Low cohesion and excessive responsibility.","answer":"God Object tendencies."}
{"Instruction":"Analyze refactoring difficulty.","question":"Refactoring one class forces changes across many dependent classes. Why?","think":"The class is overly central and tightly coupled.","answer":"God Object with strong coupling."}
{"Instruction":"Evaluate service orchestration.","question":"Services mostly pass data around while making decisions elsewhere. What is wrong?","think":"Decision logic is misplaced.","answer":"Anemic Domain Model."}
{"Instruction":"Review dependency direction.","question":"Higher-level components know too much about lower-level details. What anti-pattern emerges?","think":"Abstractions are bypassed.","answer":"Tight Coupling."}
{"Instruction":"Analyze feature implementation.","question":"Each new feature adds small changes to many existing classes. What does this reveal?","think":"The design does not localize change.","answer":"Shotgun Surgery."}
{"Instruction":"Review ownership of behavior.","question":"Objects exist mainly as data holders with behavior externalized. Why is this harmful?","think":"Behavior and data should evolve together.","answer":"Anemic Domain weakens encapsulation."}
{"Instruction":"Evaluate interface usage.","question":"Clients depend on many methods they do not use. What smell is this?","think":"Interfaces are too broad.","answer":"This signals Tight Coupling."}
{"Instruction":"Analyze cross-module dependencies.","question":"Multiple modules depend on a single utility class that changes often. What anti-pattern is forming?","think":"Centralized volatile dependency.","answer":"Utility God Object."}
{"Instruction":"Review business rule placement.","question":"Business rules are duplicated across controllers and services. What does this imply?","think":"Rules are not centralized or owned.","answer":"Shotgun Surgery risk."}
{"Instruction":"Evaluate encapsulation breaches.","question":"Callers must update multiple objects in the correct order to maintain invariants. Why is this bad?","think":"Invariants are not enforced by a single owner.","answer":"This is Feature Envy and poor encapsulation."}
{"Instruction":"Analyze evolution of core models.","question":"Core domain objects rarely change while services grow complex. What is the smell?","think":"Behavior avoids the domain model.","answer":"Anemic Domain Model."}
{"Instruction":"Review abstraction stability.","question":"A widely used abstraction changes frequently. What anti-pattern does this suggest?","think":"Too many responsibilities are hidden behind it.","answer":"It behaves like a God Object."}
{"Instruction":"Evaluate change locality.","question":"Adding validation rules requires updates in multiple validators, services, and controllers. Why?","think":"Validation is scattered.","answer":"Shotgun Surgery."}
{"Instruction":"Analyze coupling symptoms.","question":"Removing one component requires large refactors elsewhere. What does this indicate?","think":"Components are not independently replaceable.","answer":"Tight Coupling."}
{"Instruction":"Review domain behavior placement.","question":"Complex business logic is implemented outside domain entities for convenience. What is the consequence?","think":"The domain model loses authority.","answer":"Anemic Domain Model."}
{"Instruction":"Evaluate system health.","question":"One class is referenced by almost every module. Why is this dangerous?","think":"It becomes a bottleneck for change.","answer":"Classic God Object."}
{"Instruction":"Review the code for performance optimization.","question":"A function recalculates the same value multiple times in a loop. What is the issue?","think":"Repeated computation increases time complexity unnecessarily.","answer":"Cache the result instead of recomputing."}
{"Instruction":"Analyze readability and intent.","question":"A complex expression combines multiple conditions and calculations in one line. Why is this problematic?","think":"Dense expressions increase cognitive load and hide intent.","answer":"Split logic into named intermediate steps."}
{"Instruction":"Evaluate refactoring opportunities.","question":"A method performs validation, transformation, and execution sequentially. What should be improved?","think":"Multiple concerns reduce clarity and reuse.","answer":"Extract each concern into a separate function."}
{"Instruction":"Review algorithm efficiency.","question":"An O(n²) loop is used for duplicate detection. Why is this suboptimal?","think":"Better data structures can reduce time complexity.","answer":"Use a hash-based lookup to get O(n)."}
{"Instruction":"Analyze code clarity.","question":"Early errors are handled at the end of a long function. Why is this hard to read?","think":"Delayed error handling obscures the happy path.","answer":"Use guard clauses to fail fast."}
{"Instruction":"Evaluate memory usage.","question":"Large intermediate collections are built only to be iterated once. What is the optimization?","think":"Materialization increases memory pressure.","answer":"Stream or process elements incrementally."}
{"Instruction":"Review loop structure.","question":"Nested loops contain repeated condition checks. Why is this inefficient?","think":"Redundant checks waste CPU cycles.","answer":"Hoist invariant conditions out of loops."}
{"Instruction":"Analyze naming and structure.","question":"Helper functions are named generically (e.g., process, handle). Why is this harmful?","think":"Names fail to communicate intent.","answer":"Rename functions to reflect purpose."}
{"Instruction":"Evaluate hot-path design.","question":"Logging occurs inside a performance-critical loop. What is the cost?","think":"I/O and formatting dominate execution time.","answer":"Remove or batch logging in hot paths."}
{"Instruction":"Review conditional logic.","question":"A long if-else chain checks the same variable repeatedly. What is the refactor?","think":"Repeated branching reduces readability and scalability.","answer":"Replace with a lookup or strategy."}
{"Instruction":"Analyze object allocation.","question":"Temporary objects are created for trivial transformations. Why optimize this?","think":"Allocation and GC add overhead.","answer":"Avoid unnecessary allocations."}
{"Instruction":"Evaluate function size.","question":"A function spans several screens. Why is this an issue?","think":"Large functions hide structure and intent.","answer":"Decompose into smaller functions."}
{"Instruction":"Review data access patterns.","question":"The same collection is scanned multiple times for different conditions. What is the inefficiency?","think":"Multiple passes increase constant factors.","answer":"Combine passes into one."}
{"Instruction":"Analyze control flow.","question":"Deeply nested conditionals make behavior hard to trace. What is the refactor?","think":"Nesting increases cognitive complexity.","answer":"Flatten logic with early returns."}
{"Instruction":"Evaluate abstraction cost.","question":"Simple logic is wrapped in multiple abstraction layers. Why is this suboptimal?","think":"Over-abstraction adds indirection without value.","answer":"Inline or simplify the abstraction."}
{"Instruction":"Review duplication.","question":"Similar logic appears with minor variations across functions. What should be done?","think":"Duplication increases maintenance cost.","answer":"Extract shared logic."}
{"Instruction":"Analyze error handling.","question":"Errors are converted to default values silently. Why is this dangerous?","think":"Failures become invisible.","answer":"Make errors explicit."}
{"Instruction":"Evaluate data structure choice.","question":"A list is used for frequent membership checks. What is the cost?","think":"Linear search increases time complexity.","answer":"Use a set or map."}
{"Instruction":"Review readability vs optimization trade-off.","question":"Highly optimized code is difficult to understand. What should guide decisions?","think":"Maintainability usually outweighs micro-optimizations.","answer":"Optimize only measured bottlenecks."}
{"Instruction":"Analyze method contracts.","question":"A function mutates its input unexpectedly. Why is this problematic?","think":"Hidden side effects break assumptions.","answer":"Avoid or clearly document mutation."}
{"Instruction":"Evaluate loop termination.","question":"Loop exit conditions are spread across multiple places. Why is this risky?","think":"Termination logic becomes error-prone.","answer":"Centralize exit conditions."}
{"Instruction":"Review code evolution.","question":"Small changes repeatedly require touching the same function. What does this signal?","think":"The function has too many responsibilities.","answer":"Refactor to reduce responsibility."}
{"Instruction":"Analyze data transformation.","question":"Data is converted back and forth between formats repeatedly. Why optimize this?","think":"Serialization and parsing are expensive.","answer":"Reduce format conversions."}
{"Instruction":"Evaluate readability of optimizations.","question":"Bit-level tricks are used without explanation. Why is this harmful?","think":"Future maintainers may remove or misuse them.","answer":"Prefer clear code or document intent."}
{"Instruction":"Review refactoring readiness.","question":"The code has no tests, blocking refactoring. What is the first step?","think":"Refactoring without safety nets is risky.","answer":"Add tests before refactoring."}
{"Instruction":"Analyze boundary conditions.","question":"Edge cases are handled inline with main logic. Why refactor this?","think":"Edge handling obscures core flow.","answer":"Isolate edge-case handling."}
{"Instruction":"Evaluate performance assumptions.","question":"Code is optimized based on intuition rather than data. Why is this risky?","think":"Intuition often misidentifies bottlenecks.","answer":"Profile before optimizing."}
{"Instruction":"Review code intent.","question":"The implementation reveals how but not why. What is missing?","think":"Intent aids long-term understanding.","answer":"Add intention-revealing structure or comments."}
{"Instruction":"Review the code as a senior engineer.","question":"This function assumes inputs are always valid and skips validation. What is the concern?","think":"Production systems inevitably receive invalid or unexpected input.","answer":"Add explicit validation or fail fast."}
{"Instruction":"Review performance impact.","question":"A hot-path function allocates new objects on every call. Why flag this?","think":"Frequent allocations increase GC pressure and tail latency.","answer":"Reduce allocations in the hot path."}
{"Instruction":"Review maintainability.","question":"Business rules are embedded directly in controller logic. What is the issue?","think":"Tight coupling makes changes ripple across layers.","answer":"Move business rules out of the controller."}
{"Instruction":"Review scalability.","question":"A shared mutable map is accessed without synchronization. Why is this risky?","think":"Concurrency bugs surface under load, not in tests.","answer":"Make access thread-safe or immutable."}
{"Instruction":"Review code evolution.","question":"Adding a new feature requires editing several unrelated files. What does this indicate?","think":"Change amplification signals poor modular boundaries.","answer":"Revisit module boundaries."}
{"Instruction":"Review readability.","question":"This optimization relies on subtle ordering guarantees. Why comment on it?","think":"Future changes may break hidden assumptions.","answer":"Document the ordering dependency."}
{"Instruction":"Review error handling.","question":"Errors are logged but execution continues as if nothing happened. Why push back?","think":"Silent failure corrupts system state.","answer":"Either handle the error or propagate it."}
{"Instruction":"Review data access.","question":"The same database query is executed inside a loop. What is the problem?","think":"Repeated I/O dominates execution time.","answer":"Move the query outside the loop."}
{"Instruction":"Review abstraction level.","question":"A low-level utility knows about high-level business concepts. Why is this bad?","think":"Abstractions should depend inward, not outward.","answer":"Decouple utility from business logic."}
{"Instruction":"Review naming.","question":"Variable names reflect how data is stored rather than what it represents. Why change them?","think":"Names should convey intent, not implementation.","answer":"Rename to reflect domain meaning."}
{"Instruction":"Review defensive coding.","question":"A public method mutates arguments passed by reference. Why is this flagged?","think":"Callers may rely on immutability.","answer":"Avoid mutating caller-owned data."}
{"Instruction":"Review performance assumptions.","question":"Caching is added without eviction strategy. Why is this dangerous?","think":"Unbounded caches cause memory leaks.","answer":"Define eviction or size limits."}
{"Instruction":"Review testability.","question":"Core logic depends directly on system time. What is the issue?","think":"Hard dependencies make tests flaky.","answer":"Inject time as a dependency."}
{"Instruction":"Review refactoring safety.","question":"A large refactor is proposed without tests. Why push back?","think":"Behavior changes become undetectable.","answer":"Add tests before refactoring."}
{"Instruction":"Review coupling.","question":"Multiple modules reach into each other’s internal state. Why is this fragile?","think":"Encapsulation boundaries are violated.","answer":"Expose behavior, not state."}
{"Instruction":"Review control flow.","question":"Normal flow is mixed with exceptional handling logic. Why separate them?","think":"Happy path should be easy to follow.","answer":"Isolate exceptional paths."}
{"Instruction":"Review performance profiling.","question":"Optimizations were added without measurements. Why object?","think":"Most guesses about bottlenecks are wrong.","answer":"Profile before optimizing."}
{"Instruction":"Review API design.","question":"A method returns null to signal multiple failure modes. Why improve this?","think":"Ambiguous contracts cause misuse.","answer":"Use explicit error signaling."}
{"Instruction":"Review code duplication.","question":"Similar logic exists in multiple services with slight differences. Why unify?","think":"Bug fixes won’t propagate consistently.","answer":"Extract shared behavior."}
{"Instruction":"Review data structures.","question":"A list is used where ordering is irrelevant but lookups are frequent. Why comment?","think":"Wrong structure increases asymptotic cost.","answer":"Use a set or map."}
{"Instruction":"Review future extensibility.","question":"Adding a new case requires modifying a large switch statement. Why is this a smell?","think":"Violates open-closed principle.","answer":"Replace with polymorphic dispatch."}
{"Instruction":"Review code clarity.","question":"Magic numbers appear throughout performance-sensitive code. Why flag them?","think":"They obscure intent and tuning rationale.","answer":"Replace with named constants."}
{"Instruction":"Review state management.","question":"State transitions are implicit and scattered. Why is this risky?","think":"Invalid states become representable.","answer":"Centralize state transitions."}
{"Instruction":"Review concurrency.","question":"Locks are held while performing I/O. Why is this a problem?","think":"Long lock hold times reduce throughput.","answer":"Avoid I/O inside locks."}
{"Instruction":"Review logging strategy.","question":"Verbose logging is enabled by default in production paths. Why change it?","think":"Logging can dominate latency.","answer":"Lower default log level."}
{"Instruction":"Review architectural drift.","question":"A helper class gradually accumulates unrelated responsibilities. What is happening?","think":"This is how God objects emerge.","answer":"Split responsibilities early."}
{"Instruction":"Review code intent.","question":"The code is correct but non-obvious. Why still request changes?","think":"Clarity prevents future regressions.","answer":"Make intent explicit."}
{"Instruction":"Review performance vs readability.","question":"Micro-optimizations obscure logic with negligible gain. What is the guidance?","think":"Maintenance cost outweighs benefit.","answer":"Prefer clarity over micro-optimizations."}
{"Instruction":"Review API boundaries.","question":"Internal data structures are exposed directly to callers. Why is this unsafe?","think":"Callers become coupled to internals.","answer":"Return stable abstractions."}
{"Instruction":"Review change risk.","question":"A small feature change modifies core infrastructure code. Why raise concern?","think":"Blast radius is too large.","answer":"Isolate feature-specific changes."}
